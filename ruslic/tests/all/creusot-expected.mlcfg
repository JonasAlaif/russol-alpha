
module Creusot_Node_Type
  type t_node 't =
    | C_Nil
    | C_Cons 't (t_node 't)
    
  let function cons_elem (self : t_node 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Nil -> any 't
      | C_Cons a _ -> a
      end
  let function cons_next (self : t_node 't) : t_node 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Nil -> any t_node 't
      | C_Cons _ a -> a
      end
end
module Creusot_Impl0_Len_Stub
  type t
  use prelude.Int
  use Creusot_Node_Type as Creusot_Node_Type
  function len [#"/all/creusot.rs" 21 4 21 30] (self : Creusot_Node_Type.t_node t) : int
end
module Creusot_Impl0_Len_Interface
  type t
  use prelude.Int
  use Creusot_Node_Type as Creusot_Node_Type
  function len [#"/all/creusot.rs" 21 4 21 30] (self : Creusot_Node_Type.t_node t) : int
  axiom len_spec : forall self : Creusot_Node_Type.t_node t . [#"/all/creusot.rs" 17 14 20 6] len self = match (self) with
    | Creusot_Node_Type.C_Nil -> 0
    | Creusot_Node_Type.C_Cons _ next -> 1 + len next
    end
end
module Creusot_Impl0_Len
  type t
  use prelude.Int
  use Creusot_Node_Type as Creusot_Node_Type
  function len [#"/all/creusot.rs" 21 4 21 30] (self : Creusot_Node_Type.t_node t) : int
  val len [#"/all/creusot.rs" 21 4 21 30] (self : Creusot_Node_Type.t_node t) : int
    ensures { result = len self }
    
  axiom len_spec : forall self : Creusot_Node_Type.t_node t . [#"/all/creusot.rs" 17 14 20 6] len self = match (self) with
    | Creusot_Node_Type.C_Nil -> 0
    | Creusot_Node_Type.C_Cons _ next -> 1 + len next
    end
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_Boxed_Box_Type
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_box 't 'a =
    | C_Box (Core_Ptr_Unique_Unique_Type.t_unique 't) 'a
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Creusot_Impl0_Singleton_Interface
  type t
  use Creusot_Node_Type as Creusot_Node_Type
  val singleton [#"/all/creusot.rs" 28 4 28 37] (elem : t) : Creusot_Node_Type.t_node t
end
module Creusot_Impl0_Singleton
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = t
  let rec cfg singleton [#"/all/creusot.rs" 28 4 28 37] [@cfg:stackify] [@cfg:subregion_analysis] (elem : t) : Creusot_Node_Type.t_node t
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Node_Type.t_node t;
  var elem_1 : t;
  var next_2 : Creusot_Node_Type.t_node t;
  var _3 : Creusot_Node_Type.t_node t;
  var _4 : t;
  var _5 : Creusot_Node_Type.t_node t;
  {
    elem_1 <- elem;
    goto BB0
  }
  BB0 {
    _3 <- Creusot_Node_Type.C_Nil;
    next_2 <- _3;
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _4 };
    _4 <- elem_1;
    elem_1 <- any t;
    assume { Resolve1.resolve _5 };
    _5 <- next_2;
    next_2 <- any Creusot_Node_Type.t_node t;
    _0 <- Creusot_Node_Type.C_Cons _4 _5;
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Creusot_Impl0_Peek_Interface
  type t
  use prelude.Int
  use prelude.Borrow
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = t,
    axiom .
  val peek [#"/all/creusot.rs" 34 4 34 28] (self : Creusot_Node_Type.t_node t) : t
    requires {[#"/all/creusot.rs" 33 15 33 29] Len0.len self > 0}
    
end
module Creusot_Impl0_Peek
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = t
  use Creusot_Node_Type as Creusot_Node_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_Node_Type.t_node t
  clone Creusot_Impl0_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg peek [#"/all/creusot.rs" 34 4 34 28] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Node_Type.t_node t) : t
    requires {[#"/all/creusot.rs" 33 15 33 29] Len0.len self > 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var self_1 : Creusot_Node_Type.t_node t;
  var _3 : t;
  var _4 : isize;
  var _5 : ();
  var elem_6 : t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    elem_6 <- Creusot_Node_Type.cons_elem self_1;
    assume { Resolve0.resolve self_1 };
    _3 <- elem_6;
    assume { Resolve1.resolve elem_6 };
    _0 <- _3;
    assume { Resolve1.resolve _3 };
    return _0
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
     ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module Creusot_Impl0_PushLen_Interface
  type t
  use prelude.Borrow
  use prelude.Int
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = t,
    axiom .
  val push_len [#"/all/creusot.rs" 42 4 42 39] (self : borrowed (Creusot_Node_Type.t_node t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 41 14 41 45] Len0.len ( ^ self) = Len0.len ( * self) + 1 }
    
end
module Creusot_Impl0_PushLen
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Node_Type.t_node t
  clone Creusot_Impl0_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg push_len [#"/all/creusot.rs" 42 4 42 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Node_Type.t_node t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 41 14 41 45] Len0.len ( ^ self) = Len0.len ( * self) + 1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_Node_Type.t_node t);
  var elem_2 : t;
  var _4 : isize;
  var next_5 : Creusot_Node_Type.t_node t;
  var _6 : Creusot_Node_Type.t_node t;
  var new_7 : Creusot_Node_Type.t_node t;
  var _8 : t;
  var _9 : Creusot_Node_Type.t_node t;
  var _10 : Creusot_Node_Type.t_node t;
  var next_11 : borrowed (Creusot_Node_Type.t_node t);
  var _12 : borrowed (Creusot_Node_Type.t_node t);
  var _13 : t;
  {
    self_1 <- self;
    elem_2 <- elem;
    goto BB0
  }
  BB0 {
    switch ( * self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    next_11 <- borrow_mut (Creusot_Node_Type.cons_next ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Node_Type.C_Cons a b =  * self_1 in Creusot_Node_Type.C_Cons a ( ^ next_11)) };
    assume { Resolve0.resolve self_1 };
    _12 <- borrow_mut ( * next_11);
    next_11 <- { next_11 with current = ( ^ _12) };
    assume { Resolve2.resolve next_11 };
    assume { Resolve1.resolve _13 };
    _13 <- elem_2;
    elem_2 <- any t;
    _0 <- ([#"/all/creusot.rs" 49 35 49 54] push_len _12 _13);
    goto BB12
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve elem_2 };
    absurd
  }
  BB3 {
    _6 <- Creusot_Node_Type.C_Nil;
    next_5 <- _6;
    goto BB4
  }
  BB4 {
    assume { Resolve1.resolve _8 };
    _8 <- elem_2;
    elem_2 <- any t;
    assume { Resolve3.resolve _9 };
    _9 <- next_5;
    next_5 <- any Creusot_Node_Type.t_node t;
    new_7 <- Creusot_Node_Type.C_Cons _8 _9;
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    assume { Resolve4.resolve _10 };
    _10 <- new_7;
    new_7 <- any Creusot_Node_Type.t_node t;
    goto BB7
  }
  BB7 {
    assume { Resolve4.resolve ( * self_1) };
    self_1 <- { self_1 with current = _10 };
    _10 <- any Creusot_Node_Type.t_node t;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB13
  }
  BB12 {
    goto BB13
  }
  BB13 {
    goto BB14
  }
  BB14 {
    return _0
  }
  
end
module Creusot_Replace_Interface
  type t
  use prelude.Borrow
  val replace [#"/all/creusot.rs" 1758 0 1758 40] (dest : borrowed t) (src : t) : t
    ensures { [#"/all/creusot.rs" 1756 10 1756 25]  * dest = result }
    ensures { [#"/all/creusot.rs" 1757 10 1757 22]  ^ dest = src }
    
end
module Creusot_Impl0_Push_Interface
  type t
  use prelude.Borrow
  use Creusot_Node_Type as Creusot_Node_Type
  val push [#"/all/creusot.rs" 57 4 57 35] (self : borrowed (Creusot_Node_Type.t_node t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 53 14 56 5] match ( ^ self) with
      | Creusot_Node_Type.C_Cons _ next -> next =  * self
      | Creusot_Node_Type.C_Nil -> false
      end }
    
end
module Creusot_Impl0_Push
  type t
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_Node_Type.t_node t
  clone Creusot_Replace_Interface as Replace0 with
    type t = Creusot_Node_Type.t_node t
  let rec cfg push [#"/all/creusot.rs" 57 4 57 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Node_Type.t_node t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 53 14 56 5] match ( ^ self) with
      | Creusot_Node_Type.C_Cons _ next -> next =  * self
      | Creusot_Node_Type.C_Nil -> false
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_Node_Type.t_node t);
  var elem_2 : t;
  var result_4 : Creusot_Node_Type.t_node t;
  var _5 : borrowed (Creusot_Node_Type.t_node t);
  var _6 : Creusot_Node_Type.t_node t;
  var next_7 : Creusot_Node_Type.t_node t;
  var _8 : Creusot_Node_Type.t_node t;
  var new_9 : Creusot_Node_Type.t_node t;
  var _10 : t;
  var _11 : Creusot_Node_Type.t_node t;
  var _12 : Creusot_Node_Type.t_node t;
  {
    self_1 <- self;
    elem_2 <- elem;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _5) };
    _6 <- Creusot_Node_Type.C_Nil;
    result_4 <- ([#"/all/creusot.rs" 58 19 58 43] Replace0.replace _5 _6);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _8 };
    _8 <- result_4;
    result_4 <- any Creusot_Node_Type.t_node t;
    next_7 <- _8;
    goto BB2
  }
  BB2 {
    assume { Resolve1.resolve _10 };
    _10 <- elem_2;
    elem_2 <- any t;
    assume { Resolve2.resolve _11 };
    _11 <- next_7;
    next_7 <- any Creusot_Node_Type.t_node t;
    new_9 <- Creusot_Node_Type.C_Cons _10 _11;
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    assume { Resolve0.resolve _12 };
    _12 <- new_9;
    new_9 <- any Creusot_Node_Type.t_node t;
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve ( * self_1) };
    self_1 <- { self_1 with current = _12 };
    _12 <- any Creusot_Node_Type.t_node t;
    assume { Resolve3.resolve self_1 };
    _0 <- ();
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module Creusot_IsSome_Stub
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  function is_some [#"/all/creusot.rs" 1761 0 1761 35] (o : Core_Option_Option_Type.t_option t) : bool
end
module Creusot_IsSome_Interface
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  function is_some [#"/all/creusot.rs" 1761 0 1761 35] (o : Core_Option_Option_Type.t_option t) : bool
end
module Creusot_IsSome
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  function is_some [#"/all/creusot.rs" 1761 0 1761 35] (o : Core_Option_Option_Type.t_option t) : bool =
    [#"/all/creusot.rs" 1762 2 1762 41] match (o) with
      | Core_Option_Option_Type.C_Some _ -> true
      | _ -> false
      end
  val is_some [#"/all/creusot.rs" 1761 0 1761 35] (o : Core_Option_Option_Type.t_option t) : bool
    ensures { result = is_some o }
    
end
module Creusot_Impl0_Pop_Interface
  type t
  use prelude.Borrow
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_IsSome_Stub as IsSome0 with
    type t = t
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = t,
    axiom .
  val pop [#"/all/creusot.rs" 67 4 67 38] (self : borrowed (Creusot_Node_Type.t_node t)) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 64 4 66 6] Len0.len ( * self) > 0 -> Len0.len ( ^ self) = Len0.len ( * self) - 1 /\ IsSome0.is_some result }
    
end
module Creusot_Impl0_Pop
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Node_Type.t_node t
  clone Creusot_Replace_Interface as Replace0 with
    type t = Creusot_Node_Type.t_node t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_IsSome as IsSome0 with
    type t = t
  clone Creusot_Impl0_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg pop [#"/all/creusot.rs" 67 4 67 38] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Node_Type.t_node t)) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 64 4 66 6] Len0.len ( * self) > 0 -> Len0.len ( ^ self) = Len0.len ( * self) - 1 /\ IsSome0.is_some result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option t;
  var self_1 : borrowed (Creusot_Node_Type.t_node t);
  var result_3 : Creusot_Node_Type.t_node t;
  var _4 : borrowed (Creusot_Node_Type.t_node t);
  var _5 : Creusot_Node_Type.t_node t;
  var _6 : isize;
  var elem_7 : t;
  var next_8 : Creusot_Node_Type.t_node t;
  var _9 : Creusot_Node_Type.t_node t;
  var _10 : t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _4) };
    _5 <- Creusot_Node_Type.C_Nil;
    result_3 <- ([#"/all/creusot.rs" 68 19 68 43] Replace0.replace _4 _5);
    goto BB1
  }
  BB1 {
    switch (result_3)
      | Creusot_Node_Type.C_Nil -> goto BB4
      | Creusot_Node_Type.C_Cons _ _ -> goto BB2
      end
  }
  BB2 {
    assume { Resolve2.resolve elem_7 };
    elem_7 <- Creusot_Node_Type.cons_elem result_3;
    result_3 <- (let Creusot_Node_Type.C_Cons a b = result_3 in Creusot_Node_Type.C_Cons (any t) b);
    assume { Resolve3.resolve next_8 };
    next_8 <- Creusot_Node_Type.cons_next result_3;
    result_3 <- (let Creusot_Node_Type.C_Cons a b = result_3 in Creusot_Node_Type.C_Cons a (any Creusot_Node_Type.t_node t));
    assume { Resolve1.resolve result_3 };
    assume { Resolve1.resolve _9 };
    _9 <- next_8;
    next_8 <- any Creusot_Node_Type.t_node t;
    assume { Resolve3.resolve next_8 };
    goto BB5
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve result_3 };
    absurd
  }
  BB4 {
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve result_3 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB11
  }
  BB5 {
    assume { Resolve1.resolve ( * self_1) };
    self_1 <- { self_1 with current = _9 };
    _9 <- any Creusot_Node_Type.t_node t;
    assume { Resolve0.resolve self_1 };
    goto BB7
  }
  BB7 {
    assume { Resolve2.resolve _10 };
    _10 <- elem_7;
    elem_7 <- any t;
    _0 <- Core_Option_Option_Type.C_Some _10;
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    return _0
  }
  
end
module Creusot_Impl0_PeekLast_Interface
  type t
  use prelude.Borrow
  use prelude.Int
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = t,
    axiom .
  val peek_last [#"/all/creusot.rs" 79 4 79 44] (self : borrowed (Creusot_Node_Type.t_node t)) : borrowed (Creusot_Node_Type.t_node t)
    ensures { [#"/all/creusot.rs" 78 14 78 59] Len0.len ( ^ self) = Len0.len ( * self) + Len0.len ( ^ result) }
    
end
module Creusot_Impl0_PeekLast
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Node_Type.t_node t
  clone Creusot_Impl0_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg peek_last [#"/all/creusot.rs" 79 4 79 44] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Node_Type.t_node t)) : borrowed (Creusot_Node_Type.t_node t)
    ensures { [#"/all/creusot.rs" 78 14 78 59] Len0.len ( ^ self) = Len0.len ( * self) + Len0.len ( ^ result) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed (Creusot_Node_Type.t_node t);
  var self_1 : borrowed (Creusot_Node_Type.t_node t);
  var _2 : borrowed (Creusot_Node_Type.t_node t);
  var _4 : borrowed (Creusot_Node_Type.t_node t);
  var _5 : isize;
  var next_6 : borrowed (Creusot_Node_Type.t_node t);
  var _7 : borrowed (Creusot_Node_Type.t_node t);
  var _8 : borrowed (Creusot_Node_Type.t_node t);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch ( * self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    next_6 <- borrow_mut (Creusot_Node_Type.cons_next ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Node_Type.C_Cons a b =  * self_1 in Creusot_Node_Type.C_Cons a ( ^ next_6)) };
    assume { Resolve0.resolve self_1 };
    _8 <- borrow_mut ( * next_6);
    next_6 <- { next_6 with current = ( ^ _8) };
    assume { Resolve1.resolve next_6 };
    _7 <- ([#"/all/creusot.rs" 82 35 82 51] peek_last _8);
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    _4 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _4) };
    assume { Resolve0.resolve self_1 };
    goto BB5
  }
  BB4 {
    _4 <- borrow_mut ( * _7);
    _7 <- { _7 with current = ( ^ _4) };
    assume { Resolve0.resolve _7 };
    goto BB5
  }
  BB5 {
    _2 <- borrow_mut ( * _4);
    _4 <- { _4 with current = ( ^ _2) };
    assume { Resolve0.resolve _4 };
    _0 <- borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Resolve0.resolve _2 };
    return _0
  }
  
end
module Creusot_NodeAlt_Type
  type t_nodealt 't =
    | C_Nil
    | C_Cons ('t, t_nodealt 't)
    
  let function cons_node (self : t_nodealt 't) : ('t, t_nodealt 't) = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Nil -> any ('t, t_nodealt 't)
      | C_Cons a -> a
      end
end
module Creusot_Impl1_Len_Stub
  type t
  use prelude.Int
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  function len [#"/all/creusot.rs" 99 4 99 30] (self : Creusot_NodeAlt_Type.t_nodealt t) : int
end
module Creusot_Impl1_Len_Interface
  type t
  use prelude.Int
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  function len [#"/all/creusot.rs" 99 4 99 30] (self : Creusot_NodeAlt_Type.t_nodealt t) : int
  axiom len_spec : forall self : Creusot_NodeAlt_Type.t_nodealt t . [#"/all/creusot.rs" 95 14 98 6] len self = match (self) with
    | Creusot_NodeAlt_Type.C_Nil -> 0
    | Creusot_NodeAlt_Type.C_Cons node -> 1 + len (let (_, a) = node in a)
    end
end
module Creusot_Impl1_Len
  type t
  use prelude.Int
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  function len [#"/all/creusot.rs" 99 4 99 30] (self : Creusot_NodeAlt_Type.t_nodealt t) : int
  val len [#"/all/creusot.rs" 99 4 99 30] (self : Creusot_NodeAlt_Type.t_nodealt t) : int
    ensures { result = len self }
    
  axiom len_spec : forall self : Creusot_NodeAlt_Type.t_nodealt t . [#"/all/creusot.rs" 95 14 98 6] len self = match (self) with
    | Creusot_NodeAlt_Type.C_Nil -> 0
    | Creusot_NodeAlt_Type.C_Cons node -> 1 + len (let (_, a) = node in a)
    end
end
module CreusotContracts_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module Creusot_Impl1_Singleton_Interface
  type t
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  val singleton [#"/all/creusot.rs" 106 4 106 37] (elem : t) : Creusot_NodeAlt_Type.t_nodealt t
end
module Creusot_Impl1_Singleton
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Creusot_NodeAlt_Type.t_nodealt t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = (t, Creusot_NodeAlt_Type.t_nodealt t)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = t
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve1 with
    type t1 = t,
    type t2 = Creusot_NodeAlt_Type.t_nodealt t,
    predicate Resolve0.resolve = Resolve0.resolve,
    predicate Resolve1.resolve = Resolve3.resolve
  let rec cfg singleton [#"/all/creusot.rs" 106 4 106 37] [@cfg:stackify] [@cfg:subregion_analysis] (elem : t) : Creusot_NodeAlt_Type.t_nodealt t
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_NodeAlt_Type.t_nodealt t;
  var elem_1 : t;
  var bx_2 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _3 : t;
  var _4 : Creusot_NodeAlt_Type.t_nodealt t;
  var node_5 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _6 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _7 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  {
    elem_1 <- elem;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _3 };
    _3 <- elem_1;
    elem_1 <- any t;
    _4 <- Creusot_NodeAlt_Type.C_Nil;
    bx_2 <- (_3, _4);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    assume { Resolve1.resolve _6 };
    _6 <- bx_2;
    bx_2 <- any (t, Creusot_NodeAlt_Type.t_nodealt t);
    node_5 <- _6;
    goto BB3
  }
  BB3 {
    assume { Resolve2.resolve _7 };
    _7 <- node_5;
    node_5 <- any (t, Creusot_NodeAlt_Type.t_nodealt t);
    _0 <- Creusot_NodeAlt_Type.C_Cons _7;
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Creusot_Impl1_Peek_Interface
  type t
  use prelude.Int
  use prelude.Borrow
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  clone Creusot_Impl1_Len_Stub as Len0 with
    type t = t,
    axiom .
  val peek [#"/all/creusot.rs" 113 4 113 28] (self : Creusot_NodeAlt_Type.t_nodealt t) : t
    requires {[#"/all/creusot.rs" 112 15 112 29] Len0.len self > 0}
    
end
module Creusot_Impl1_Peek
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = (t, Creusot_NodeAlt_Type.t_nodealt t)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_NodeAlt_Type.t_nodealt t
  clone Creusot_Impl1_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg peek [#"/all/creusot.rs" 113 4 113 28] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_NodeAlt_Type.t_nodealt t) : t
    requires {[#"/all/creusot.rs" 112 15 112 29] Len0.len self > 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var self_1 : Creusot_NodeAlt_Type.t_nodealt t;
  var _3 : t;
  var _4 : isize;
  var _5 : ();
  var node_6 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _7 : t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Creusot_NodeAlt_Type.C_Nil -> goto BB3
      | Creusot_NodeAlt_Type.C_Cons _ -> goto BB1
      end
  }
  BB1 {
    node_6 <- Creusot_NodeAlt_Type.cons_node self_1;
    assume { Resolve0.resolve self_1 };
    _7 <- (let (a, _) = node_6 in a);
    assume { Resolve1.resolve node_6 };
    _3 <- _7;
    assume { Resolve2.resolve _7 };
    _0 <- _3;
    assume { Resolve2.resolve _3 };
    return _0
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  
end
module Creusot_Impl1_PushLen_Interface
  type t
  use prelude.Borrow
  use prelude.Int
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  clone Creusot_Impl1_Len_Stub as Len0 with
    type t = t,
    axiom .
  val push_len [#"/all/creusot.rs" 121 4 121 39] (self : borrowed (Creusot_NodeAlt_Type.t_nodealt t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 120 14 120 45] Len0.len ( ^ self) = Len0.len ( * self) + 1 }
    
end
module Creusot_Impl1_PushLen
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = Creusot_NodeAlt_Type.t_nodealt t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = (t, Creusot_NodeAlt_Type.t_nodealt t)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = t
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve3 with
    type t1 = t,
    type t2 = Creusot_NodeAlt_Type.t_nodealt t,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve5.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = (t, Creusot_NodeAlt_Type.t_nodealt t)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_NodeAlt_Type.t_nodealt t
  clone Creusot_Impl1_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg push_len [#"/all/creusot.rs" 121 4 121 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_NodeAlt_Type.t_nodealt t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 120 14 120 45] Len0.len ( ^ self) = Len0.len ( * self) + 1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var elem_2 : t;
  var _4 : isize;
  var bx_5 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _6 : t;
  var _7 : Creusot_NodeAlt_Type.t_nodealt t;
  var node_8 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _9 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var new_10 : Creusot_NodeAlt_Type.t_nodealt t;
  var _11 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _12 : Creusot_NodeAlt_Type.t_nodealt t;
  var node_13 : borrowed (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _14 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var _15 : t;
  {
    self_1 <- self;
    elem_2 <- elem;
    goto BB0
  }
  BB0 {
    switch ( * self_1)
      | Creusot_NodeAlt_Type.C_Nil -> goto BB3
      | Creusot_NodeAlt_Type.C_Cons _ -> goto BB1
      end
  }
  BB1 {
    node_13 <- borrow_mut (Creusot_NodeAlt_Type.cons_node ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_NodeAlt_Type.C_Cons a =  * self_1 in Creusot_NodeAlt_Type.C_Cons ( ^ node_13)) };
    assume { Resolve0.resolve self_1 };
    _14 <- borrow_mut (let (_, a) =  * node_13 in a);
    node_13 <- { node_13 with current = (let (a, b) =  * node_13 in (a,  ^ _14)) };
    assume { Resolve2.resolve node_13 };
    assume { Resolve1.resolve _15 };
    _15 <- elem_2;
    elem_2 <- any t;
    _0 <- ([#"/all/creusot.rs" 129 34 129 55] push_len _14 _15);
    goto BB14
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve elem_2 };
    absurd
  }
  BB3 {
    assume { Resolve1.resolve _6 };
    _6 <- elem_2;
    elem_2 <- any t;
    _7 <- Creusot_NodeAlt_Type.C_Nil;
    bx_5 <- (_6, _7);
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    assume { Resolve3.resolve _9 };
    _9 <- bx_5;
    bx_5 <- any (t, Creusot_NodeAlt_Type.t_nodealt t);
    node_8 <- _9;
    goto BB6
  }
  BB6 {
    assume { Resolve4.resolve _11 };
    _11 <- node_8;
    node_8 <- any (t, Creusot_NodeAlt_Type.t_nodealt t);
    new_10 <- Creusot_NodeAlt_Type.C_Cons _11;
    goto BB7
  }
  BB7 {
    assume { Resolve5.resolve _12 };
    _12 <- new_10;
    new_10 <- any Creusot_NodeAlt_Type.t_nodealt t;
    goto BB8
  }
  BB8 {
    assume { Resolve5.resolve ( * self_1) };
    self_1 <- { self_1 with current = _12 };
    _12 <- any Creusot_NodeAlt_Type.t_nodealt t;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    goto BB15
  }
  BB14 {
    goto BB15
  }
  BB15 {
    goto BB16
  }
  BB16 {
    return _0
  }
  
end
module Creusot_Impl1_Push_Interface
  type t
  use prelude.Borrow
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  val push [#"/all/creusot.rs" 137 4 137 35] (self : borrowed (Creusot_NodeAlt_Type.t_nodealt t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 133 14 136 5] match ( ^ self) with
      | Creusot_NodeAlt_Type.C_Cons node -> (let (_, a) = node in a) =  * self
      | Creusot_NodeAlt_Type.C_Nil -> false
      end }
    
end
module Creusot_Impl1_Push
  type t
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve4 with
    type t = Creusot_NodeAlt_Type.t_nodealt t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = (t, Creusot_NodeAlt_Type.t_nodealt t)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Creusot_NodeAlt_Type.t_nodealt t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = t
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve2 with
    type t1 = t,
    type t2 = Creusot_NodeAlt_Type.t_nodealt t,
    predicate Resolve0.resolve = Resolve0.resolve,
    predicate Resolve1.resolve = Resolve1.resolve
  clone Creusot_Replace_Interface as Replace0 with
    type t = Creusot_NodeAlt_Type.t_nodealt t
  let rec cfg push [#"/all/creusot.rs" 137 4 137 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_NodeAlt_Type.t_nodealt t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 133 14 136 5] match ( ^ self) with
      | Creusot_NodeAlt_Type.C_Cons node -> (let (_, a) = node in a) =  * self
      | Creusot_NodeAlt_Type.C_Nil -> false
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var elem_2 : t;
  var result_4 : Creusot_NodeAlt_Type.t_nodealt t;
  var _5 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var _6 : Creusot_NodeAlt_Type.t_nodealt t;
  var bx_7 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _8 : t;
  var _9 : Creusot_NodeAlt_Type.t_nodealt t;
  var node_10 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _11 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var new_12 : Creusot_NodeAlt_Type.t_nodealt t;
  var _13 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _14 : Creusot_NodeAlt_Type.t_nodealt t;
  {
    self_1 <- self;
    elem_2 <- elem;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _5) };
    _6 <- Creusot_NodeAlt_Type.C_Nil;
    result_4 <- ([#"/all/creusot.rs" 138 19 138 46] Replace0.replace _5 _6);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _8 };
    _8 <- elem_2;
    elem_2 <- any t;
    assume { Resolve1.resolve _9 };
    _9 <- result_4;
    result_4 <- any Creusot_NodeAlt_Type.t_nodealt t;
    bx_7 <- (_8, _9);
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    assume { Resolve2.resolve _11 };
    _11 <- bx_7;
    bx_7 <- any (t, Creusot_NodeAlt_Type.t_nodealt t);
    node_10 <- _11;
    goto BB4
  }
  BB4 {
    assume { Resolve3.resolve _13 };
    _13 <- node_10;
    node_10 <- any (t, Creusot_NodeAlt_Type.t_nodealt t);
    new_12 <- Creusot_NodeAlt_Type.C_Cons _13;
    goto BB5
  }
  BB5 {
    assume { Resolve1.resolve _14 };
    _14 <- new_12;
    new_12 <- any Creusot_NodeAlt_Type.t_nodealt t;
    goto BB6
  }
  BB6 {
    assume { Resolve1.resolve ( * self_1) };
    self_1 <- { self_1 with current = _14 };
    _14 <- any Creusot_NodeAlt_Type.t_nodealt t;
    assume { Resolve4.resolve self_1 };
    _0 <- ();
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Creusot_Impl1_Pop_Interface
  type t
  use prelude.Borrow
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  clone Creusot_IsSome_Stub as IsSome0 with
    type t = t
  clone Creusot_Impl1_Len_Stub as Len0 with
    type t = t,
    axiom .
  val pop [#"/all/creusot.rs" 148 4 148 38] (self : borrowed (Creusot_NodeAlt_Type.t_nodealt t)) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 145 4 147 6] Len0.len ( * self) > 0 -> Len0.len ( ^ self) = Len0.len ( * self) - 1 /\ IsSome0.is_some result }
    
end
module Creusot_Impl1_Pop
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = (t, Creusot_NodeAlt_Type.t_nodealt t)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Creusot_NodeAlt_Type.t_nodealt t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_NodeAlt_Type.t_nodealt t
  clone Creusot_Replace_Interface as Replace0 with
    type t = Creusot_NodeAlt_Type.t_nodealt t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_IsSome as IsSome0 with
    type t = t
  clone Creusot_Impl1_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg pop [#"/all/creusot.rs" 148 4 148 38] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_NodeAlt_Type.t_nodealt t)) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 145 4 147 6] Len0.len ( * self) > 0 -> Len0.len ( ^ self) = Len0.len ( * self) - 1 /\ IsSome0.is_some result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option t;
  var self_1 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var result_3 : Creusot_NodeAlt_Type.t_nodealt t;
  var _4 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var _5 : Creusot_NodeAlt_Type.t_nodealt t;
  var _6 : isize;
  var node_7 : (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _8 : Creusot_NodeAlt_Type.t_nodealt t;
  var _9 : t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _4) };
    _5 <- Creusot_NodeAlt_Type.C_Nil;
    result_3 <- ([#"/all/creusot.rs" 149 19 149 46] Replace0.replace _4 _5);
    goto BB1
  }
  BB1 {
    switch (result_3)
      | Creusot_NodeAlt_Type.C_Nil -> goto BB4
      | Creusot_NodeAlt_Type.C_Cons _ -> goto BB2
      end
  }
  BB2 {
    assume { Resolve2.resolve node_7 };
    node_7 <- Creusot_NodeAlt_Type.cons_node result_3;
    result_3 <- (let Creusot_NodeAlt_Type.C_Cons a = result_3 in Creusot_NodeAlt_Type.C_Cons (any (t, Creusot_NodeAlt_Type.t_nodealt t)));
    assume { Resolve1.resolve result_3 };
    assume { Resolve1.resolve _8 };
    _8 <- (let (_, a) = node_7 in a);
    node_7 <- (let (a, b) = node_7 in (a, any Creusot_NodeAlt_Type.t_nodealt t));
    goto BB5
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve result_3 };
    absurd
  }
  BB4 {
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve result_3 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB10
  }
  BB5 {
    assume { Resolve1.resolve ( * self_1) };
    self_1 <- { self_1 with current = _8 };
    _8 <- any Creusot_NodeAlt_Type.t_nodealt t;
    assume { Resolve0.resolve self_1 };
    goto BB7
  }
  BB7 {
    assume { Resolve3.resolve _9 };
    _9 <- (let (a, _) = node_7 in a);
    node_7 <- (let (a, b) = node_7 in (any t, b));
    assume { Resolve2.resolve node_7 };
    _0 <- Core_Option_Option_Type.C_Some _9;
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Creusot_Impl1_PeekLast_Interface
  type t
  use prelude.Borrow
  use prelude.Int
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  clone Creusot_Impl1_Len_Stub as Len0 with
    type t = t,
    axiom .
  val peek_last [#"/all/creusot.rs" 160 4 160 44] (self : borrowed (Creusot_NodeAlt_Type.t_nodealt t)) : borrowed (Creusot_NodeAlt_Type.t_nodealt t)
    ensures { [#"/all/creusot.rs" 159 14 159 59] Len0.len ( ^ self) = Len0.len ( * self) + Len0.len ( ^ result) }
    
end
module Creusot_Impl1_PeekLast
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeAlt_Type as Creusot_NodeAlt_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = (t, Creusot_NodeAlt_Type.t_nodealt t)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_NodeAlt_Type.t_nodealt t
  clone Creusot_Impl1_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg peek_last [#"/all/creusot.rs" 160 4 160 44] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_NodeAlt_Type.t_nodealt t)) : borrowed (Creusot_NodeAlt_Type.t_nodealt t)
    ensures { [#"/all/creusot.rs" 159 14 159 59] Len0.len ( ^ self) = Len0.len ( * self) + Len0.len ( ^ result) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var self_1 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var _2 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var _4 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var _5 : isize;
  var node_6 : borrowed (t, Creusot_NodeAlt_Type.t_nodealt t);
  var _7 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  var _8 : borrowed (Creusot_NodeAlt_Type.t_nodealt t);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch ( * self_1)
      | Creusot_NodeAlt_Type.C_Nil -> goto BB3
      | Creusot_NodeAlt_Type.C_Cons _ -> goto BB1
      end
  }
  BB1 {
    node_6 <- borrow_mut (Creusot_NodeAlt_Type.cons_node ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_NodeAlt_Type.C_Cons a =  * self_1 in Creusot_NodeAlt_Type.C_Cons ( ^ node_6)) };
    assume { Resolve0.resolve self_1 };
    _8 <- borrow_mut (let (_, a) =  * node_6 in a);
    node_6 <- { node_6 with current = (let (a, b) =  * node_6 in (a,  ^ _8)) };
    assume { Resolve1.resolve node_6 };
    _7 <- ([#"/all/creusot.rs" 163 34 163 52] peek_last _8);
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    _4 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _4) };
    assume { Resolve0.resolve self_1 };
    goto BB5
  }
  BB4 {
    _4 <- borrow_mut ( * _7);
    _7 <- { _7 with current = ( ^ _4) };
    assume { Resolve0.resolve _7 };
    goto BB5
  }
  BB5 {
    _2 <- borrow_mut ( * _4);
    _4 <- { _4 with current = ( ^ _2) };
    assume { Resolve0.resolve _4 };
    _0 <- borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Resolve0.resolve _2 };
    return _0
  }
  
end
module Creusot_TripleNested_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  val triple_nested [#"/all/creusot.rs" 177 0 177 93] (x : borrowed (borrowed (borrowed int32))) (y : borrowed (borrowed int32)) (z : borrowed int32) : ()
    requires {[#"/all/creusot.rs" 172 11 172 24]  *  *  * x = (7 : int32)}
    ensures { [#"/all/creusot.rs" 173 12 173 24]  ^  ^  ^ x =  ^  ^ y }
    ensures { [#"/all/creusot.rs" 174 12 174 24]  *  ^  ^ x =  *  ^ y }
    ensures { [#"/all/creusot.rs" 175 12 175 23]  ^  *  ^ x =  ^ z }
    ensures { [#"/all/creusot.rs" 176 12 176 26]  *  *  ^ x = (11 : int32) }
    
end
module Creusot_TripleNested
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = borrowed (borrowed int32)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = borrowed int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  let rec cfg triple_nested [#"/all/creusot.rs" 177 0 177 93] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (borrowed (borrowed int32))) (y : borrowed (borrowed int32)) (z : borrowed int32) : ()
    requires {[#"/all/creusot.rs" 172 11 172 24]  *  *  * x = (7 : int32)}
    ensures { [#"/all/creusot.rs" 173 12 173 24]  ^  ^  ^ x =  ^  ^ y }
    ensures { [#"/all/creusot.rs" 174 12 174 24]  *  ^  ^ x =  *  ^ y }
    ensures { [#"/all/creusot.rs" 175 12 175 23]  ^  *  ^ x =  ^ z }
    ensures { [#"/all/creusot.rs" 176 12 176 26]  *  *  ^ x = (11 : int32) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed (borrowed (borrowed int32));
  var y_2 : borrowed (borrowed int32);
  var z_3 : borrowed int32;
  var _9 : int32;
  var _10 : borrowed int32;
  var _11 : borrowed (borrowed int32);
  {
    x_1 <- x;
    y_2 <- y;
    z_3 <- z;
    goto BB0
  }
  BB0 {
    _9 <- ([#"/all/creusot.rs" 178 7 178 9] (11 : int32));
    z_3 <- { z_3 with current = _9 };
    _9 <- any int32;
    _10 <- borrow_mut ( * z_3);
    z_3 <- { z_3 with current = ( ^ _10) };
    assume { Resolve0.resolve z_3 };
    assume { Resolve0.resolve ( * y_2) };
    y_2 <- { y_2 with current = _10 };
    _10 <- any borrowed int32;
    _11 <- borrow_mut ( * y_2);
    y_2 <- { y_2 with current = ( ^ _11) };
    assume { Resolve1.resolve y_2 };
    assume { Resolve1.resolve ( * x_1) };
    x_1 <- { x_1 with current = _11 };
    _11 <- any borrowed (borrowed int32);
    assume { Resolve2.resolve x_1 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_TripleNested2_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  val triple_nested_2 [#"/all/creusot.rs" 184 0 184 95] (x : borrowed (borrowed (borrowed int32))) (y : borrowed (borrowed int32)) (z : borrowed int32) : ()
    ensures { [#"/all/creusot.rs" 183 12 183 21]  ^  ^ y =  ^ z }
    
end
module Creusot_TripleNested2
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = borrowed int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = borrowed (borrowed int32)
  let rec cfg triple_nested_2 [#"/all/creusot.rs" 184 0 184 95] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (borrowed (borrowed int32))) (y : borrowed (borrowed int32)) (z : borrowed int32) : ()
    ensures { [#"/all/creusot.rs" 183 12 183 21]  ^  ^ y =  ^ z }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed (borrowed (borrowed int32));
  var y_2 : borrowed (borrowed int32);
  var z_3 : borrowed int32;
  var _5 : borrowed int32;
  {
    x_1 <- x;
    y_2 <- y;
    z_3 <- z;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve x_1 };
    _5 <- borrow_mut ( * z_3);
    z_3 <- { z_3 with current = ( ^ _5) };
    assume { Resolve1.resolve z_3 };
    assume { Resolve1.resolve ( * y_2) };
    y_2 <- { y_2 with current = _5 };
    _5 <- any borrowed int32;
    assume { Resolve2.resolve y_2 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_BorrowIn_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  val borrow_in [#"/all/creusot.rs" 189 0 189 52] (x : borrowed (borrowed int32)) : borrowed int32
    ensures { [#"/all/creusot.rs" 188 10 188 24]  *  ^ x =  ^ result }
    
end
module Creusot_BorrowIn
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = borrowed int32
  let rec cfg borrow_in [#"/all/creusot.rs" 189 0 189 52] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (borrowed int32)) : borrowed int32
    ensures { [#"/all/creusot.rs" 188 10 188 24]  *  ^ x =  ^ result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed int32;
  var x_1 : borrowed (borrowed int32);
  var _2 : borrowed int32;
  var _4 : borrowed int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _4 <- borrow_mut ( *  * x_1);
    x_1 <- { x_1 with current = { ( * x_1) with current = ( ^ _4) } };
    assume { Resolve0.resolve x_1 };
    _2 <- borrow_mut ( * _4);
    _4 <- { _4 with current = ( ^ _2) };
    assume { Resolve1.resolve _4 };
    _0 <- borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Resolve1.resolve _2 };
    return _0
  }
  
end
module Core_Num_Impl7_Max_Stub
  use prelude.Int
  use prelude.UInt16
  val constant mAX'  : uint16
end
module Core_Num_Impl7_Max
  use prelude.Int
  use prelude.UInt16
  let constant mAX'  : uint16 = [@vc:do_not_keep_trace] [@vc:sp]
    (65535 : uint16)
end
module Creusot_WriteAndReborrow_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  clone Core_Num_Impl7_Max_Stub as Max0
  val write_and_reborrow [#"/all/creusot.rs" 196 0 196 62] (x : borrowed (borrowed uint16)) (y : borrowed uint16) : ()
    requires {[#"/all/creusot.rs" 193 11 193 31]  *  * x +  * y <= Max0.mAX'}
    ensures { [#"/all/creusot.rs" 194 10 194 25]  *  ^ x =  *  * x +  * y }
    ensures { [#"/all/creusot.rs" 195 10 195 19]  ^  ^ x =  ^ y }
    
end
module Creusot_WriteAndReborrow
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = borrowed uint16
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = uint16
  clone Core_Num_Impl7_Max as Max0
  let rec cfg write_and_reborrow [#"/all/creusot.rs" 196 0 196 62] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (borrowed uint16)) (y : borrowed uint16) : ()
    requires {[#"/all/creusot.rs" 193 11 193 31]  *  * x +  * y <= Max0.mAX'}
    ensures { [#"/all/creusot.rs" 194 10 194 25]  *  ^ x =  *  * x +  * y }
    ensures { [#"/all/creusot.rs" 195 10 195 19]  ^  ^ x =  ^ y }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed (borrowed uint16);
  var y_2 : borrowed uint16;
  var de_6 : uint16;
  var de_de_7 : uint16;
  var _8 : uint16;
  var _9 : uint16;
  var _10 : uint16;
  var _11 : borrowed uint16;
  {
    x_1 <- x;
    y_2 <- y;
    goto BB0
  }
  BB0 {
    de_6 <-  * y_2;
    de_de_7 <-  *  * x_1;
    _9 <- de_de_7;
    _10 <- de_6;
    _8 <- ([#"/all/creusot.rs" 199 7 199 19] _9 + _10);
    y_2 <- { y_2 with current = _8 };
    _8 <- any uint16;
    _11 <- borrow_mut ( * y_2);
    y_2 <- { y_2 with current = ( ^ _11) };
    assume { Resolve0.resolve y_2 };
    assume { Resolve0.resolve ( * x_1) };
    x_1 <- { x_1 with current = _11 };
    _11 <- any borrowed uint16;
    assume { Resolve1.resolve x_1 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_Private_Percentage_Type
  use prelude.Int
  use prelude.UInt16
  type t_percentage  =
    | C_Percentage uint16
    
  let function percentage_0 (self : t_percentage) : uint16 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Percentage a -> a
      end
end
module Creusot_Private_IsTen_Stub
  use Creusot_Private_Percentage_Type as Creusot_Private_Percentage_Type
  function is_ten [#"/all/creusot.rs" 224 13 224 49] (p : Creusot_Private_Percentage_Type.t_percentage) : bool
end
module Creusot_Private_IsTen_Interface
  use Creusot_Private_Percentage_Type as Creusot_Private_Percentage_Type
  function is_ten [#"/all/creusot.rs" 224 13 224 49] (p : Creusot_Private_Percentage_Type.t_percentage) : bool
end
module Creusot_Private_IsTen
  use prelude.Int
  use prelude.UInt16
  use Creusot_Private_Percentage_Type as Creusot_Private_Percentage_Type
  function is_ten [#"/all/creusot.rs" 224 13 224 49] (p : Creusot_Private_Percentage_Type.t_percentage) : bool =
    [#"/all/creusot.rs" 224 52 224 65] Creusot_Private_Percentage_Type.percentage_0 p = (10 : uint16)
  val is_ten [#"/all/creusot.rs" 224 13 224 49] (p : Creusot_Private_Percentage_Type.t_percentage) : bool
    ensures { result = is_ten p }
    
end
module Creusot_Private_Bar_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  use Creusot_Private_Percentage_Type as Creusot_Private_Percentage_Type
  clone Creusot_Private_IsTen_Stub as IsTen0
  val bar [#"/all/creusot.rs" 220 4 220 46] (p : borrowed (Creusot_Private_Percentage_Type.t_percentage)) : borrowed uint16
    ensures { [#"/all/creusot.rs" 217 14 217 28]  * result = Creusot_Private_Percentage_Type.percentage_0 ( * p) }
    ensures { [#"/all/creusot.rs" 218 14 218 31]  ^ result = Creusot_Private_Percentage_Type.percentage_0 ( ^ p) }
    ensures { [#"/all/creusot.rs" 219 4 219 65] if  ^ result = (10 : uint16) then IsTen0.is_ten ( ^ p) else true }
    
end
module Creusot_PercetageInner_Interface
  use prelude.Borrow
  use Creusot_Private_Percentage_Type as Creusot_Private_Percentage_Type
  clone Creusot_Private_IsTen_Stub as IsTen0
  val percetage_inner [#"/all/creusot.rs" 228 0 228 47] (p : borrowed (Creusot_Private_Percentage_Type.t_percentage)) : ()
    ensures { [#"/all/creusot.rs" 227 10 227 29] IsTen0.is_ten ( ^ p) }
    
end
module Creusot_PercetageInner
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = uint16
  use Creusot_Private_Percentage_Type as Creusot_Private_Percentage_Type
  clone Creusot_Private_IsTen as IsTen0
  clone Creusot_Private_Bar_Interface as Bar0 with
    function IsTen0.is_ten = IsTen0.is_ten
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Private_Percentage_Type.t_percentage
  let rec cfg percetage_inner [#"/all/creusot.rs" 228 0 228 47] [@cfg:stackify] [@cfg:subregion_analysis] (p : borrowed (Creusot_Private_Percentage_Type.t_percentage)) : ()
    ensures { [#"/all/creusot.rs" 227 10 227 29] IsTen0.is_ten ( ^ p) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var p_1 : borrowed (Creusot_Private_Percentage_Type.t_percentage);
  var result_3 : borrowed uint16;
  var _4 : borrowed (Creusot_Private_Percentage_Type.t_percentage);
  var _5 : uint16;
  {
    p_1 <- p;
    goto BB0
  }
  BB0 {
    _4 <- borrow_mut ( * p_1);
    p_1 <- { p_1 with current = ( ^ _4) };
    assume { Resolve0.resolve p_1 };
    result_3 <- ([#"/all/creusot.rs" 229 15 229 30] Bar0.bar _4);
    goto BB1
  }
  BB1 {
    _5 <- ([#"/all/creusot.rs" 230 12 230 14] (10 : uint16));
    result_3 <- { result_3 with current = _5 };
    _5 <- any uint16;
    assume { Resolve1.resolve result_3 };
    _0 <- ();
    return _0
  }
  
end
module Core_Clone_Clone_Clone_Interface
  type self
  use prelude.Borrow
  val clone' (self : self) : self
    ensures { [#"/all/creusot.rs" 1054 10 1069 33] result = self }
    
end
module Creusot_CloneCheck1_Interface
  type t
  use prelude.Borrow
  val clone_check_1 [#"/all/creusot.rs" 233 0 233 38] (x : t) : t
end
module Creusot_CloneCheck1
  type t
  use prelude.Borrow
  clone Core_Clone_Clone_Clone_Interface as Clone0 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = t
  let rec cfg clone_check_1 [#"/all/creusot.rs" 233 0 233 38] [@cfg:stackify] [@cfg:subregion_analysis] (x : t) : t
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var x_1 : t;
  var _2 : t;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _2 <- x_1;
    assume { Resolve0.resolve x_1 };
    _0 <- ([#"/all/creusot.rs" 234 2 234 11] Clone0.clone' _2);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module Creusot_Foo_Type
  type t_foo 't =
    | C_Foo 't
    
  let function foo_0 (self : t_foo 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Foo a -> a
      end
end
module Creusot_Impl2_CloneCheck2_Interface
  type t
  use prelude.Borrow
  use Creusot_Foo_Type as Creusot_Foo_Type
  val clone_check_2 [#"/all/creusot.rs" 238 4 238 35] (self : Creusot_Foo_Type.t_foo t) : Creusot_Foo_Type.t_foo t
end
module Creusot_Impl2_CloneCheck2
  type t
  use prelude.Borrow
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = t
  clone Core_Clone_Clone_Clone_Interface as Clone0 with
    type self = t
  use Creusot_Foo_Type as Creusot_Foo_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_Foo_Type.t_foo t
  let rec cfg clone_check_2 [#"/all/creusot.rs" 238 4 238 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Foo_Type.t_foo t) : Creusot_Foo_Type.t_foo t
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Foo_Type.t_foo t;
  var self_1 : Creusot_Foo_Type.t_foo t;
  var result_2 : t;
  var _3 : t;
  var _4 : t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _3 <- Creusot_Foo_Type.foo_0 self_1;
    assume { Resolve0.resolve self_1 };
    result_2 <- ([#"/all/creusot.rs" 239 19 239 33] Clone0.clone' _3);
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve _4 };
    _4 <- result_2;
    result_2 <- any t;
    _0 <- Creusot_Foo_Type.C_Foo _4;
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    return _0
  }
  
end
module Creusot_BorrowAndValue_Type
  use prelude.Borrow
  type t_borrowandvalue 't =
    | C_BorrowAndValue (borrowed 't) 't
    
end
module Creusot_Impl3_New_Interface
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Creusot_BorrowAndValue_Type as Creusot_BorrowAndValue_Type
  val new [#"/all/creusot.rs" 246 4 246 65] (borrow : borrowed t) (b2 : borrowed int32) : Creusot_BorrowAndValue_Type.t_borrowandvalue t
    
end
module Creusot_Impl3_New
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  use Creusot_BorrowAndValue_Type as Creusot_BorrowAndValue_Type
  let rec cfg new [#"/all/creusot.rs" 246 4 246 65] [@cfg:stackify] [@cfg:subregion_analysis] (borrow : borrowed t) (b2 : borrowed int32) : Creusot_BorrowAndValue_Type.t_borrowandvalue t
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_BorrowAndValue_Type.t_borrowandvalue t;
  var borrow_1 : borrowed t;
  var b2_2 : borrowed int32;
  var de_3 : t;
  var _4 : borrowed t;
  var _5 : t;
  {
    borrow_1 <- borrow;
    b2_2 <- b2;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve b2_2 };
    assume { Resolve1.resolve de_3 };
    de_3 <-  * borrow_1;
    _4 <- borrow_mut ( * borrow_1);
    borrow_1 <- { borrow_1 with current = ( ^ _4) };
    assume { Resolve2.resolve borrow_1 };
    assume { Resolve1.resolve _5 };
    _5 <- de_3;
    assume { Resolve1.resolve de_3 };
    _0 <- Creusot_BorrowAndValue_Type.C_BorrowAndValue _4 _5;
    return _0
  }
  
end
module Creusot_Foo2_Type
  use prelude.Int
  use prelude.Int32
  type t_foo2  =
    | C_Foo2 int32
    
end
module Creusot_Impl30_Clone_Interface
  use prelude.Borrow
  use Creusot_Foo2_Type as Creusot_Foo2_Type
  val clone' [#"/all/creusot.rs" 252 15 252 32] (self : Creusot_Foo2_Type.t_foo2) : Creusot_Foo2_Type.t_foo2
end
module Creusot_Impl30_Clone
  use prelude.Borrow
  use Creusot_Foo2_Type as Creusot_Foo2_Type
  let rec cfg clone' [#"/all/creusot.rs" 252 15 252 32] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Foo2_Type.t_foo2) : Creusot_Foo2_Type.t_foo2
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Foo2_Type.t_foo2;
  var self_1 : Creusot_Foo2_Type.t_foo2;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _0 <- self_1;
    return _0
  }
  
end
module Creusot_CopyOut_Interface
  use prelude.Borrow
  use Creusot_Foo2_Type as Creusot_Foo2_Type
  val copy_out [#"/all/creusot.rs" 254 0 254 29] (x : Creusot_Foo2_Type.t_foo2) : Creusot_Foo2_Type.t_foo2
end
module Creusot_CopyOut
  use prelude.Borrow
  use Creusot_Foo2_Type as Creusot_Foo2_Type
  let rec cfg copy_out [#"/all/creusot.rs" 254 0 254 29] [@cfg:stackify] [@cfg:subregion_analysis] (x : Creusot_Foo2_Type.t_foo2) : Creusot_Foo2_Type.t_foo2
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Foo2_Type.t_foo2;
  var x_1 : Creusot_Foo2_Type.t_foo2;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _0 <- x_1;
    return _0
  }
  
end
module CreusotContracts_Logic_Set_Impl0_Insert_Stub
  type t
  use set.Set
  function insert [@inline:trivial] (self : Set.set t) (e : t) : Set.set t
end
module CreusotContracts_Logic_Set_Impl0_Insert_Interface
  type t
  use set.Set
  function insert [@inline:trivial] (self : Set.set t) (e : t) : Set.set t
end
module CreusotContracts_Logic_Set_Impl0_Insert
  type t
  use set.Set
  function insert [@inline:trivial] (self : Set.set t) (e : t) : Set.set t =
    [#"/all/creusot.rs" 997 23 998 10] Set.add e self
  val insert [@inline:trivial] (self : Set.set t) (e : t) : Set.set t
    ensures { result = insert self e }
    
end
module Creusot_Impl4_Elems_Stub
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_Node_Type as Creusot_Node_Type
  function elems [#"/all/creusot.rs" 265 4 265 35] (self : Creusot_Node_Type.t_node t) : Set.set t
end
module Creusot_Impl4_Elems_Interface
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_Node_Type as Creusot_Node_Type
  function elems [#"/all/creusot.rs" 265 4 265 35] (self : Creusot_Node_Type.t_node t) : Set.set t
  axiom elems_spec : forall self : Creusot_Node_Type.t_node t . [#"/all/creusot.rs" 261 14 264 6] elems self = match (self) with
    | Creusot_Node_Type.C_Nil -> Set.empty 
    | Creusot_Node_Type.C_Cons elem next -> Insert0.insert (elems next) elem
    end
end
module Creusot_Impl4_Elems
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_Node_Type as Creusot_Node_Type
  function elems [#"/all/creusot.rs" 265 4 265 35] (self : Creusot_Node_Type.t_node t) : Set.set t
  val elems [#"/all/creusot.rs" 265 4 265 35] (self : Creusot_Node_Type.t_node t) : Set.set t
    ensures { result = elems self }
    
  axiom elems_spec : forall self : Creusot_Node_Type.t_node t . [#"/all/creusot.rs" 261 14 264 6] elems self = match (self) with
    | Creusot_Node_Type.C_Nil -> Set.empty 
    | Creusot_Node_Type.C_Cons elem next -> Insert0.insert (elems next) elem
    end
end
module Creusot_Impl4_ModifyElems_Interface
  type t
  use prelude.Borrow
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl0_Len_Stub as Len1 with
    type t = t,
    axiom .
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = borrowed t,
    axiom .
  val modify_elems [#"/all/creusot.rs" 273 4 273 46] (self : borrowed (Creusot_Node_Type.t_node t)) : Creusot_Node_Type.t_node (borrowed t)
    ensures { [#"/all/creusot.rs" 272 14 272 40] Len0.len result = Len1.len ( * self) }
    
end
module Creusot_Impl4_ModifyElems
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Creusot_Node_Type.t_node (borrowed t)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Creusot_Node_Type.t_node (borrowed t)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Node_Type.t_node t
  clone Creusot_Impl0_Len as Len1 with
    type t = t,
    axiom .
  clone Creusot_Impl0_Len as Len0 with
    type t = borrowed t,
    axiom .
  let rec cfg modify_elems [#"/all/creusot.rs" 273 4 273 46] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Node_Type.t_node t)) : Creusot_Node_Type.t_node (borrowed t)
    ensures { [#"/all/creusot.rs" 272 14 272 40] Len0.len result = Len1.len ( * self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Node_Type.t_node (borrowed t);
  var self_1 : borrowed (Creusot_Node_Type.t_node t);
  var _3 : isize;
  var elem_4 : borrowed t;
  var next_5 : borrowed (Creusot_Node_Type.t_node t);
  var result_6 : Creusot_Node_Type.t_node (borrowed t);
  var _7 : borrowed (Creusot_Node_Type.t_node t);
  var next_8 : Creusot_Node_Type.t_node (borrowed t);
  var _9 : Creusot_Node_Type.t_node (borrowed t);
  var _10 : borrowed t;
  var _11 : Creusot_Node_Type.t_node (borrowed t);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch ( * self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    elem_4 <- borrow_mut (Creusot_Node_Type.cons_elem ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Node_Type.C_Cons a b =  * self_1 in Creusot_Node_Type.C_Cons ( ^ elem_4) b) };
    next_5 <- borrow_mut (Creusot_Node_Type.cons_next ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Node_Type.C_Cons a b =  * self_1 in Creusot_Node_Type.C_Cons a ( ^ next_5)) };
    assume { Resolve0.resolve self_1 };
    _7 <- borrow_mut ( * next_5);
    next_5 <- { next_5 with current = ( ^ _7) };
    assume { Resolve1.resolve next_5 };
    result_6 <- ([#"/all/creusot.rs" 277 23 277 42] modify_elems _7);
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    _0 <- Creusot_Node_Type.C_Nil;
    goto BB9
  }
  BB4 {
    assume { Resolve2.resolve _9 };
    _9 <- result_6;
    result_6 <- any Creusot_Node_Type.t_node (borrowed t);
    next_8 <- _9;
    goto BB5
  }
  BB5 {
    _10 <- borrow_mut ( * elem_4);
    elem_4 <- { elem_4 with current = ( ^ _10) };
    assume { Resolve3.resolve elem_4 };
    assume { Resolve4.resolve _11 };
    _11 <- next_8;
    next_8 <- any Creusot_Node_Type.t_node (borrowed t);
    _0 <- Creusot_Node_Type.C_Cons _10 _11;
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module Creusot_Impl5_Sum_Stub
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  function sum [#"/all/creusot.rs" 292 4 292 23] (self : Creusot_Node_Type.t_node int32) : int32
end
module Creusot_Impl5_Sum_Interface
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  function sum [#"/all/creusot.rs" 292 4 292 23] (self : Creusot_Node_Type.t_node int32) : int32
  axiom sum_spec : forall self : Creusot_Node_Type.t_node int32 . [#"/all/creusot.rs" 288 14 291 6] sum self = match (self) with
    | Creusot_Node_Type.C_Nil -> (0 : int32)
    | Creusot_Node_Type.C_Cons elem next -> elem + sum next
    end
end
module Creusot_Impl5_Sum
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  function sum [#"/all/creusot.rs" 292 4 292 23] (self : Creusot_Node_Type.t_node int32) : int32
  val sum [#"/all/creusot.rs" 292 4 292 23] (self : Creusot_Node_Type.t_node int32) : int32
    ensures { result = sum self }
    
  axiom sum_spec : forall self : Creusot_Node_Type.t_node int32 . [#"/all/creusot.rs" 288 14 291 6] sum self = match (self) with
    | Creusot_Node_Type.C_Nil -> (0 : int32)
    | Creusot_Node_Type.C_Cons elem next -> elem + sum next
    end
end
module Creusot_Impl5_ElemsEq_Stub
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  function elems_eq [#"/all/creusot.rs" 300 4 300 29] (self : Creusot_Node_Type.t_node int32) : bool
end
module Creusot_Impl5_ElemsEq_Interface
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  function elems_eq [#"/all/creusot.rs" 300 4 300 29] (self : Creusot_Node_Type.t_node int32) : bool
end
module Creusot_Impl5_ElemsEq
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  function elems_eq [#"/all/creusot.rs" 300 4 300 29] (self : Creusot_Node_Type.t_node int32) : bool
  val elems_eq [#"/all/creusot.rs" 300 4 300 29] (self : Creusot_Node_Type.t_node int32) : bool
    ensures { result = elems_eq self }
    
  axiom def : forall self : Creusot_Node_Type.t_node int32 . elems_eq self = ([#"/all/creusot.rs" 301 8 312 9] match (self) with
    | Creusot_Node_Type.C_Cons elem next -> let tmp = elem in match (next) with
      | Creusot_Node_Type.C_Cons elem _ -> tmp = elem /\ elems_eq next
      | next -> elems_eq next
      end
    | _ -> true
    end)
end
module Creusot_Impl5_ElemsEq_Impl
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  let rec ghost function elems_eq [#"/all/creusot.rs" 300 4 300 29] (self : Creusot_Node_Type.t_node int32) : bool
    variant {[#"/all/creusot.rs" 299 14 299 18] self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/all/creusot.rs" 301 8 312 9] match (self) with
      | Creusot_Node_Type.C_Cons elem next -> let tmp = elem in match (next) with
        | Creusot_Node_Type.C_Cons elem _ -> pure {tmp = elem} && elems_eq next
        | next -> elems_eq next
        end
      | _ -> true
      end
end
module Creusot_Impl5_LenGt0_Stub
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  function len_gt0 [#"/all/creusot.rs" 317 4 317 34] (self : Creusot_Node_Type.t_node int32) : int
end
module Creusot_Impl5_LenGt0_Interface
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  function len_gt0 [#"/all/creusot.rs" 317 4 317 34] (self : Creusot_Node_Type.t_node int32) : int
end
module Creusot_Impl5_LenGt0
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = int32,
    axiom .
  function len_gt0 [#"/all/creusot.rs" 317 4 317 34] (self : Creusot_Node_Type.t_node int32) : int
  val len_gt0 [#"/all/creusot.rs" 317 4 317 34] (self : Creusot_Node_Type.t_node int32) : int
    ensures { result = len_gt0 self }
    
  axiom def : forall self : Creusot_Node_Type.t_node int32 . len_gt0 self = ([#"/all/creusot.rs" 318 8 321 9] match (self) with
    | Creusot_Node_Type.C_Nil -> 0
    | Creusot_Node_Type.C_Cons _ next -> 1 + Len0.len next
    end)
end
module Creusot_Impl5_LenGt0_Impl
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl0_Len as Len0 with
    type t = int32,
    axiom .
  let rec ghost function len_gt0 [#"/all/creusot.rs" 317 4 317 34] (self : Creusot_Node_Type.t_node int32) : int
    variant {[#"/all/creusot.rs" 315 14 315 18] self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/all/creusot.rs" 318 8 321 9] match (self) with
      | Creusot_Node_Type.C_Nil -> 0
      | Creusot_Node_Type.C_Cons _ next -> 1 + Len0.len next
      end
end
module Creusot_Impl5_CalcLen_Interface
  use prelude.Borrow
  use prelude.UInt16
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  clone Core_Num_Impl7_Max_Stub as Max0
  clone Creusot_Impl5_LenGt0_Stub as LenGt00 with
    axiom .
  val calc_len [#"/all/creusot.rs" 344 4 344 33] (self : borrowed (Creusot_Node_Type.t_node int32)) : uint16
    requires {[#"/all/creusot.rs" 341 15 341 42] LenGt00.len_gt0 ( * self) <= UInt16.to_int Max0.mAX'}
    ensures { [#"/all/creusot.rs" 342 14 342 49] LenGt00.len_gt0 ( ^ self) = LenGt00.len_gt0 ( * self) }
    ensures { [#"/all/creusot.rs" 343 14 343 39] UInt16.to_int result = LenGt00.len_gt0 ( * self) }
    
end
module Creusot_Impl5_CalcLen
  use prelude.Int
  use prelude.UInt16
  use prelude.Borrow
  use prelude.Int32
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone Creusot_Impl0_Len as Len0 with
    type t = int32,
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Creusot_Node_Type.t_node int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Node_Type.t_node int32
  clone Core_Num_Impl7_Max as Max0
  clone Creusot_Impl5_LenGt0 as LenGt00 with
    function Len0.len = Len0.len,
    axiom .
  let rec cfg calc_len [#"/all/creusot.rs" 344 4 344 33] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Node_Type.t_node int32)) : uint16
    requires {[#"/all/creusot.rs" 341 15 341 42] LenGt00.len_gt0 ( * self) <= UInt16.to_int Max0.mAX'}
    ensures { [#"/all/creusot.rs" 342 14 342 49] LenGt00.len_gt0 ( ^ self) = LenGt00.len_gt0 ( * self) }
    ensures { [#"/all/creusot.rs" 343 14 343 39] UInt16.to_int result = LenGt00.len_gt0 ( * self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint16;
  var self_1 : borrowed (Creusot_Node_Type.t_node int32);
  var _5 : isize;
  var next_6 : borrowed (Creusot_Node_Type.t_node int32);
  var result_7 : uint16;
  var _8 : borrowed (Creusot_Node_Type.t_node int32);
  var _9 : uint16;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch ( * self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    next_6 <- borrow_mut (Creusot_Node_Type.cons_next ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Node_Type.C_Cons a b =  * self_1 in Creusot_Node_Type.C_Cons a ( ^ next_6)) };
    assume { Resolve0.resolve self_1 };
    _8 <- borrow_mut ( * next_6);
    next_6 <- { next_6 with current = ( ^ _8) };
    assume { Resolve1.resolve next_6 };
    result_7 <- ([#"/all/creusot.rs" 348 23 348 38] calc_len _8);
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"/all/creusot.rs" 346 21 346 22] (0 : uint16));
    goto BB5
  }
  BB4 {
    _9 <- result_7;
    _0 <- ([#"/all/creusot.rs" 349 10 349 22] _9 + ([#"/all/creusot.rs" 349 20 349 21] (1 : uint16)));
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Creusot_Tuple_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  type t_tuple  =
    | C_Tuple (borrowed int32) (borrowed (Creusot_Node_Type.t_node int32))
    
  let function tuple_1 (self : t_tuple) : borrowed (Creusot_Node_Type.t_node int32) = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Tuple _ a -> a
      end
  let function tuple_0 (self : t_tuple) : borrowed int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Tuple a _ -> a
      end
end
module Creusot_Impl5_ReborrowHeadAndTail2_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = int32
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl4_Elems_Stub as Elems0 with
    type t = int32,
    function Insert0.insert = Insert0.insert,
    axiom .
  use Creusot_Tuple_Type as Creusot_Tuple_Type
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = int32,
    axiom .
  val reborrow_head_and_tail_2 [#"/all/creusot.rs" 360 4 360 91] (i : borrowed (borrowed (Creusot_Node_Type.t_node int32))) : Creusot_Tuple_Type.t_tuple
    requires {[#"/all/creusot.rs" 354 15 354 27] Len0.len ( *  * i) >= 2}
    ensures { [#"/all/creusot.rs" 355 14 355 49] Len0.len ( *  ^ i) = 2 + Len0.len ( ^ Creusot_Tuple_Type.tuple_1 result) }
    ensures { [#"/all/creusot.rs" 356 14 359 5] Elems0.elems ( *  ^ i) = match ( *  * i) with
      | Creusot_Node_Type.C_Cons elem _ -> Insert0.insert (Insert0.insert (Elems0.elems ( ^ Creusot_Tuple_Type.tuple_1 result)) elem) ( ^ Creusot_Tuple_Type.tuple_0 result)
      | _ -> Set.empty 
      end }
    
end
module Creusot_Impl5_ReborrowHeadAndTail2
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use prelude.IntSize
  use set.Set
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Creusot_Node_Type.t_node int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Creusot_Node_Type.t_node int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = borrowed (Creusot_Node_Type.t_node int32)
  clone CreusotContracts_Logic_Set_Impl0_Insert as Insert0 with
    type t = int32
  clone Creusot_Impl4_Elems as Elems0 with
    type t = int32,
    function Insert0.insert = Insert0.insert,
    axiom .
  clone Creusot_Impl0_Len as Len0 with
    type t = int32,
    axiom .
  use Creusot_Tuple_Type as Creusot_Tuple_Type
  let rec cfg reborrow_head_and_tail_2 [#"/all/creusot.rs" 360 4 360 91] [@cfg:stackify] [@cfg:subregion_analysis] (i : borrowed (borrowed (Creusot_Node_Type.t_node int32))) : Creusot_Tuple_Type.t_tuple
    requires {[#"/all/creusot.rs" 354 15 354 27] Len0.len ( *  * i) >= 2}
    ensures { [#"/all/creusot.rs" 355 14 355 49] Len0.len ( *  ^ i) = 2 + Len0.len ( ^ Creusot_Tuple_Type.tuple_1 result) }
    ensures { [#"/all/creusot.rs" 356 14 359 5] Elems0.elems ( *  ^ i) = match ( *  * i) with
      | Creusot_Node_Type.C_Cons elem _ -> Insert0.insert (Insert0.insert (Elems0.elems ( ^ Creusot_Tuple_Type.tuple_1 result)) elem) ( ^ Creusot_Tuple_Type.tuple_0 result)
      | _ -> Set.empty 
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Tuple_Type.t_tuple;
  var i_1 : borrowed (borrowed (Creusot_Node_Type.t_node int32));
  var _5 : borrowed (Creusot_Node_Type.t_node int32);
  var _6 : isize;
  var _7 : ();
  var next_8 : borrowed (Creusot_Node_Type.t_node int32);
  var _9 : borrowed (Creusot_Node_Type.t_node int32);
  var _10 : isize;
  var _11 : ();
  var elem_12 : borrowed int32;
  var next_13 : borrowed (Creusot_Node_Type.t_node int32);
  var _14 : borrowed int32;
  var _15 : borrowed (Creusot_Node_Type.t_node int32);
  var _16 : borrowed (Creusot_Node_Type.t_node int32);
  {
    i_1 <- i;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut ( *  * i_1);
    i_1 <- { i_1 with current = { ( * i_1) with current = ( ^ _5) } };
    assume { Resolve0.resolve i_1 };
    switch ( * _5)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    next_8 <- borrow_mut (Creusot_Node_Type.cons_next ( * _5));
    _5 <- { _5 with current = (let Creusot_Node_Type.C_Cons a b =  * _5 in Creusot_Node_Type.C_Cons a ( ^ next_8)) };
    assume { Resolve1.resolve _5 };
    _9 <- borrow_mut ( * next_8);
    next_8 <- { next_8 with current = ( ^ _9) };
    assume { Resolve2.resolve next_8 };
    switch ( * _9)
      | Creusot_Node_Type.C_Nil -> goto BB6
      | Creusot_Node_Type.C_Cons _ _ -> goto BB4
      end
  }
  BB2 {
    assume { Resolve1.resolve _5 };
    absurd
  }
  BB3 {
    assume { Resolve1.resolve _5 };
    absurd
  }
  BB4 {
    elem_12 <- borrow_mut (Creusot_Node_Type.cons_elem ( * _9));
    _9 <- { _9 with current = (let Creusot_Node_Type.C_Cons a b =  * _9 in Creusot_Node_Type.C_Cons ( ^ elem_12) b) };
    next_13 <- borrow_mut (Creusot_Node_Type.cons_next ( * _9));
    _9 <- { _9 with current = (let Creusot_Node_Type.C_Cons a b =  * _9 in Creusot_Node_Type.C_Cons a ( ^ next_13)) };
    assume { Resolve1.resolve _9 };
    _14 <- borrow_mut ( * elem_12);
    elem_12 <- { elem_12 with current = ( ^ _14) };
    assume { Resolve3.resolve elem_12 };
    _16 <- borrow_mut ( * next_13);
    next_13 <- { next_13 with current = ( ^ _16) };
    assume { Resolve2.resolve next_13 };
    _15 <- borrow_mut ( * _16);
    _16 <- { _16 with current = ( ^ _15) };
    assume { Resolve1.resolve _16 };
    _0 <- Creusot_Tuple_Type.C_Tuple _14 _15;
    return _0
  }
  BB5 {
    assume { Resolve1.resolve _9 };
    absurd
  }
  BB6 {
    assume { Resolve1.resolve _9 };
    absurd
  }
  
end
module Creusot_Impl5_Tail2_Interface
  use prelude.Int
  use prelude.Int32
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = int32,
    axiom .
  val tail2 [#"/all/creusot.rs" 372 4 372 26] (self : Creusot_Node_Type.t_node int32) : Creusot_Node_Type.t_node int32
    requires {[#"/all/creusot.rs" 370 15 370 30] Len0.len self >= 2}
    ensures { [#"/all/creusot.rs" 371 14 371 44] Len0.len self - 2 = Len0.len result }
    
end
module Creusot_Impl5_Tail2
  use prelude.Int
  use prelude.Int32
  use prelude.IntSize
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl0_Len as Len0 with
    type t = int32,
    axiom .
  let rec cfg tail2 [#"/all/creusot.rs" 372 4 372 26] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Node_Type.t_node int32) : Creusot_Node_Type.t_node int32
    requires {[#"/all/creusot.rs" 370 15 370 30] Len0.len self >= 2}
    ensures { [#"/all/creusot.rs" 371 14 371 44] Len0.len self - 2 = Len0.len result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Node_Type.t_node int32;
  var self_1 : Creusot_Node_Type.t_node int32;
  var _4 : isize;
  var _5 : ();
  var next_6 : Creusot_Node_Type.t_node int32;
  var _7 : isize;
  var _8 : ();
  var next_9 : Creusot_Node_Type.t_node int32;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    switch (self_1)
      | Creusot_Node_Type.C_Nil -> goto BB5
      | Creusot_Node_Type.C_Cons _ _ -> goto BB3
      end
  }
  BB3 {
    next_6 <- Creusot_Node_Type.cons_next self_1;
    self_1 <- (let Creusot_Node_Type.C_Cons a b = self_1 in Creusot_Node_Type.C_Cons a (any Creusot_Node_Type.t_node int32));
    switch (next_6)
      | Creusot_Node_Type.C_Nil -> goto BB8
      | Creusot_Node_Type.C_Cons _ _ -> goto BB6
      end
  }
  BB4 {
    absurd
  }
  BB5 {
    absurd
  }
  BB6 {
    next_9 <- Creusot_Node_Type.cons_next next_6;
    next_6 <- (let Creusot_Node_Type.C_Cons a b = next_6 in Creusot_Node_Type.C_Cons a (any Creusot_Node_Type.t_node int32));
    _0 <- next_9;
    next_9 <- any Creusot_Node_Type.t_node int32;
    goto BB9
  }
  BB7 {
    absurd
  }
  BB8 {
    absurd
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Creusot_Tree_Type
  type t_tree 't =
    | C_Leaf
    | C_Node 't (t_tree 't) (t_tree 't)
    
  let function node_f (self : t_tree 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Leaf -> any 't
      | C_Node a _ _ -> a
      end
  let function node_left (self : t_tree 't) : t_tree 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Leaf -> any t_tree 't
      | C_Node _ a _ -> a
      end
  let function node_right (self : t_tree 't) : t_tree 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Leaf -> any t_tree 't
      | C_Node _ _ a -> a
      end
end
module Creusot_Impl7_Size_Stub
  type t
  use prelude.Int
  use Creusot_Tree_Type as Creusot_Tree_Type
  function size [#"/all/creusot.rs" 465 4 465 31] (self : Creusot_Tree_Type.t_tree t) : int
end
module Creusot_Impl7_Size_Interface
  type t
  use prelude.Int
  use Creusot_Tree_Type as Creusot_Tree_Type
  function size [#"/all/creusot.rs" 465 4 465 31] (self : Creusot_Tree_Type.t_tree t) : int
  axiom size_spec : forall self : Creusot_Tree_Type.t_tree t . [#"/all/creusot.rs" 464 14 464 25] size self >= 0
end
module Creusot_Impl7_Size
  type t
  use prelude.Int
  use Creusot_Tree_Type as Creusot_Tree_Type
  function size [#"/all/creusot.rs" 465 4 465 31] (self : Creusot_Tree_Type.t_tree t) : int
  val size [#"/all/creusot.rs" 465 4 465 31] (self : Creusot_Tree_Type.t_tree t) : int
    ensures { result = size self }
    
  axiom def : forall self : Creusot_Tree_Type.t_tree t . size self = ([#"/all/creusot.rs" 466 8 469 9] match (self) with
    | Creusot_Tree_Type.C_Leaf -> 0
    | Creusot_Tree_Type.C_Node _ left right -> 1 + size left + size right
    end)
  axiom size_spec : forall self : Creusot_Tree_Type.t_tree t . [#"/all/creusot.rs" 464 14 464 25] size self >= 0
end
module Creusot_Impl7_Size_Impl
  type t
  use prelude.Int
  use Creusot_Tree_Type as Creusot_Tree_Type
  let rec ghost function size [#"/all/creusot.rs" 465 4 465 31] (self : Creusot_Tree_Type.t_tree t) : int
    ensures { [#"/all/creusot.rs" 464 14 464 25] result >= 0 }
    variant {[#"/all/creusot.rs" 463 14 463 18] self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/all/creusot.rs" 466 8 469 9] match (self) with
      | Creusot_Tree_Type.C_Leaf -> 0
      | Creusot_Tree_Type.C_Node _ left right -> 1 + size left + size right
      end
end
module Creusot_Impl7_Elems_Stub
  type t
  use set.Set
  use Creusot_Tree_Type as Creusot_Tree_Type
  function elems [#"/all/creusot.rs" 473 4 473 35] (self : Creusot_Tree_Type.t_tree t) : Set.set t
end
module Creusot_Impl7_Elems_Interface
  type t
  use set.Set
  use Creusot_Tree_Type as Creusot_Tree_Type
  function elems [#"/all/creusot.rs" 473 4 473 35] (self : Creusot_Tree_Type.t_tree t) : Set.set t
end
module Creusot_Impl7_Elems
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_Tree_Type as Creusot_Tree_Type
  function elems [#"/all/creusot.rs" 473 4 473 35] (self : Creusot_Tree_Type.t_tree t) : Set.set t
  val elems [#"/all/creusot.rs" 473 4 473 35] (self : Creusot_Tree_Type.t_tree t) : Set.set t
    ensures { result = elems self }
    
  axiom def : forall self : Creusot_Tree_Type.t_tree t . elems self = ([#"/all/creusot.rs" 474 8 477 9] match (self) with
    | Creusot_Tree_Type.C_Leaf -> Set.empty 
    | Creusot_Tree_Type.C_Node f left right -> Insert0.insert (Set.union (elems left) (elems right)) f
    end)
end
module Creusot_Impl7_Elems_Impl
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert as Insert0 with
    type t = t
  use Creusot_Tree_Type as Creusot_Tree_Type
  let rec ghost function elems [#"/all/creusot.rs" 473 4 473 35] (self : Creusot_Tree_Type.t_tree t) : Set.set t
    variant {[#"/all/creusot.rs" 472 14 472 18] self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/all/creusot.rs" 474 8 477 9] match (self) with
      | Creusot_Tree_Type.C_Leaf -> Set.empty 
      | Creusot_Tree_Type.C_Node f left right -> let a' = let a' = elems left in let b' = elems right in Set.union a' b' in Insert0.insert a' f
      end
end
module Creusot_Impl8_Duplicate_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Creusot_Tree_Type as Creusot_Tree_Type
  clone Creusot_Impl7_Size_Stub as Size0 with
    type t = int32,
    axiom .
  val duplicate [#"/all/creusot.rs" 509 4 509 31] (self : Creusot_Tree_Type.t_tree int32) : Creusot_Tree_Type.t_tree int32
    ensures { [#"/all/creusot.rs" 508 14 508 42] Size0.size result = Size0.size self }
    
end
module Creusot_Impl8_Duplicate
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use prelude.IntSize
  use Creusot_Tree_Type as Creusot_Tree_Type
  clone Creusot_Impl7_Size as Size0 with
    type t = int32,
    axiom .
  let rec cfg duplicate [#"/all/creusot.rs" 509 4 509 31] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Tree_Type.t_tree int32) : Creusot_Tree_Type.t_tree int32
    ensures { [#"/all/creusot.rs" 508 14 508 42] Size0.size result = Size0.size self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Tree_Type.t_tree int32;
  var self_1 : Creusot_Tree_Type.t_tree int32;
  var _3 : isize;
  var f_4 : int32;
  var left_5 : Creusot_Tree_Type.t_tree int32;
  var right_6 : Creusot_Tree_Type.t_tree int32;
  var de_7 : int32;
  var result_1_8 : Creusot_Tree_Type.t_tree int32;
  var _9 : Creusot_Tree_Type.t_tree int32;
  var result_2_10 : Creusot_Tree_Type.t_tree int32;
  var _11 : Creusot_Tree_Type.t_tree int32;
  var right_12 : Creusot_Tree_Type.t_tree int32;
  var _13 : Creusot_Tree_Type.t_tree int32;
  var left_14 : Creusot_Tree_Type.t_tree int32;
  var _15 : Creusot_Tree_Type.t_tree int32;
  var _16 : int32;
  var _17 : Creusot_Tree_Type.t_tree int32;
  var _18 : Creusot_Tree_Type.t_tree int32;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Creusot_Tree_Type.C_Leaf -> goto BB3
      | Creusot_Tree_Type.C_Node _ _ _ -> goto BB1
      end
  }
  BB1 {
    f_4 <- Creusot_Tree_Type.node_f self_1;
    left_5 <- Creusot_Tree_Type.node_left self_1;
    right_6 <- Creusot_Tree_Type.node_right self_1;
    de_7 <- f_4;
    _9 <- left_5;
    result_1_8 <- ([#"/all/creusot.rs" 514 25 514 41] duplicate _9);
    goto BB4
  }
  BB2 {
    absurd
  }
  BB3 {
    _0 <- Creusot_Tree_Type.C_Leaf;
    goto BB14
  }
  BB4 {
    _11 <- right_6;
    result_2_10 <- ([#"/all/creusot.rs" 515 25 515 42] duplicate _11);
    goto BB5
  }
  BB5 {
    _13 <- result_2_10;
    result_2_10 <- any Creusot_Tree_Type.t_tree int32;
    right_12 <- _13;
    goto BB6
  }
  BB6 {
    _15 <- result_1_8;
    result_1_8 <- any Creusot_Tree_Type.t_tree int32;
    left_14 <- _15;
    goto BB7
  }
  BB7 {
    _16 <- de_7;
    _17 <- left_14;
    left_14 <- any Creusot_Tree_Type.t_tree int32;
    _18 <- right_12;
    right_12 <- any Creusot_Tree_Type.t_tree int32;
    _0 <- Creusot_Tree_Type.C_Node _16 _17 _18;
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    goto BB14
  }
  BB14 {
    return _0
  }
  
end
module Creusot_Impl8_Insert_Interface
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = int32
  use Creusot_Tree_Type as Creusot_Tree_Type
  clone Creusot_Impl7_Elems_Stub as Elems0 with
    type t = int32,
    axiom .
  val insert [#"/all/creusot.rs" 548 4 548 32] (self : borrowed (Creusot_Tree_Type.t_tree int32)) (v : int32) : ()
    ensures { [#"/all/creusot.rs" 535 14 546 5] match (( * self,  ^ self)) with
      | (Creusot_Tree_Type.C_Leaf, _) -> Elems0.elems ( ^ self) = Insert0.insert (Set.empty ) v
      | (Creusot_Tree_Type.C_Node f left right, Creusot_Tree_Type.C_Node _ l r) -> if v < f then
        Elems0.elems l = Insert0.insert (Elems0.elems left) v
      else
        if f < v then Elems0.elems r = Insert0.insert (Elems0.elems right) v else true
      
      | _ -> false
      end }
    ensures { [#"/all/creusot.rs" 547 14 547 55] Elems0.elems ( ^ self) = Insert0.insert (Elems0.elems ( * self)) v }
    
end
module Creusot_Impl8_Insert
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use prelude.IntSize
  use set.Set
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Tree_Type as Creusot_Tree_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Creusot_Tree_Type.t_tree int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Tree_Type.t_tree int32
  clone CreusotContracts_Logic_Set_Impl0_Insert as Insert0 with
    type t = int32
  clone Creusot_Impl7_Elems as Elems0 with
    type t = int32,
    function Insert0.insert = Insert0.insert,
    axiom .
  let rec cfg insert [#"/all/creusot.rs" 548 4 548 32] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Tree_Type.t_tree int32)) (v : int32) : ()
    ensures { [#"/all/creusot.rs" 535 14 546 5] match (( * self,  ^ self)) with
      | (Creusot_Tree_Type.C_Leaf, _) -> Elems0.elems ( ^ self) = Insert0.insert (Set.empty ) v
      | (Creusot_Tree_Type.C_Node f left right, Creusot_Tree_Type.C_Node _ l r) -> if v < f then
        Elems0.elems l = Insert0.insert (Elems0.elems left) v
      else
        if f < v then Elems0.elems r = Insert0.insert (Elems0.elems right) v else true
      
      | _ -> false
      end }
    ensures { [#"/all/creusot.rs" 547 14 547 55] Elems0.elems ( ^ self) = Insert0.insert (Elems0.elems ( * self)) v }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_Tree_Type.t_tree int32);
  var v_2 : int32;
  var _5 : isize;
  var right_6 : Creusot_Tree_Type.t_tree int32;
  var _7 : Creusot_Tree_Type.t_tree int32;
  var left_8 : Creusot_Tree_Type.t_tree int32;
  var _9 : Creusot_Tree_Type.t_tree int32;
  var new_10 : Creusot_Tree_Type.t_tree int32;
  var _11 : int32;
  var _12 : Creusot_Tree_Type.t_tree int32;
  var _13 : Creusot_Tree_Type.t_tree int32;
  var _14 : Creusot_Tree_Type.t_tree int32;
  var f_15 : borrowed int32;
  var left_16 : borrowed (Creusot_Tree_Type.t_tree int32);
  var right_17 : borrowed (Creusot_Tree_Type.t_tree int32);
  var de_18 : int32;
  var _19 : bool;
  var _20 : int32;
  var _21 : int32;
  var _22 : borrowed (Creusot_Tree_Type.t_tree int32);
  var _23 : int32;
  var _24 : bool;
  var _25 : int32;
  var _26 : int32;
  var _27 : borrowed (Creusot_Tree_Type.t_tree int32);
  var _28 : int32;
  {
    self_1 <- self;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    switch ( * self_1)
      | Creusot_Tree_Type.C_Leaf -> goto BB3
      | Creusot_Tree_Type.C_Node _ _ _ -> goto BB1
      end
  }
  BB1 {
    f_15 <- borrow_mut (Creusot_Tree_Type.node_f ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Tree_Type.C_Node a b c =  * self_1 in Creusot_Tree_Type.C_Node ( ^ f_15) b c) };
    left_16 <- borrow_mut (Creusot_Tree_Type.node_left ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Tree_Type.C_Node a b c =  * self_1 in Creusot_Tree_Type.C_Node a ( ^ left_16) c) };
    right_17 <- borrow_mut (Creusot_Tree_Type.node_right ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Tree_Type.C_Node a b c =  * self_1 in Creusot_Tree_Type.C_Node a b ( ^ right_17)) };
    assume { Resolve0.resolve self_1 };
    de_18 <-  * f_15;
    assume { Resolve1.resolve f_15 };
    _20 <- v_2;
    _21 <- de_18;
    _19 <- ([#"/all/creusot.rs" 558 13 558 19] _20 < _21);
    switch (_19)
      | False -> goto BB16
      | True -> goto BB14
      end
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    _7 <- Creusot_Tree_Type.C_Leaf;
    right_6 <- _7;
    goto BB4
  }
  BB4 {
    _9 <- Creusot_Tree_Type.C_Leaf;
    left_8 <- _9;
    goto BB5
  }
  BB5 {
    _11 <- v_2;
    _12 <- left_8;
    left_8 <- any Creusot_Tree_Type.t_tree int32;
    _13 <- right_6;
    right_6 <- any Creusot_Tree_Type.t_tree int32;
    new_10 <- Creusot_Tree_Type.C_Node _11 _12 _13;
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    _14 <- new_10;
    new_10 <- any Creusot_Tree_Type.t_tree int32;
    goto BB8
  }
  BB8 {
    self_1 <- { self_1 with current = _14 };
    _14 <- any Creusot_Tree_Type.t_tree int32;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    goto BB22
  }
  BB14 {
    assume { Resolve2.resolve right_17 };
    _22 <- borrow_mut ( * left_16);
    left_16 <- { left_16 with current = ( ^ _22) };
    assume { Resolve2.resolve left_16 };
    _23 <- v_2;
    _0 <- ([#"/all/creusot.rs" 558 22 558 36] insert _22 _23);
    goto BB15
  }
  BB15 {
    goto BB21
  }
  BB16 {
    assume { Resolve2.resolve left_16 };
    _25 <- de_18;
    _26 <- v_2;
    _24 <- ([#"/all/creusot.rs" 558 47 558 53] _25 < _26);
    switch (_24)
      | False -> goto BB19
      | True -> goto BB17
      end
  }
  BB17 {
    _27 <- borrow_mut ( * right_17);
    right_17 <- { right_17 with current = ( ^ _27) };
    assume { Resolve2.resolve right_17 };
    _28 <- v_2;
    _0 <- ([#"/all/creusot.rs" 558 56 558 71] insert _27 _28);
    goto BB18
  }
  BB18 {
    goto BB20
  }
  BB19 {
    assume { Resolve2.resolve right_17 };
    _0 <- ();
    goto BB20
  }
  BB20 {
    goto BB21
  }
  BB21 {
    goto BB22
  }
  BB22 {
    return _0
  }
  
end
module Creusot_OptionCustom_Type
  use prelude.Int
  use prelude.Int16
  type t_optioncustom  =
    | C_Left int16
    | C_Right int16
    
  let function right_right (self : t_optioncustom) : int16 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Left _ -> any int16
      | C_Right a -> a
      end
  let function left_left (self : t_optioncustom) : int16 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Left a -> a
      | C_Right _ -> any int16
      end
end
module Core_Num_Impl1_Max_Stub
  use prelude.Int
  use prelude.Int16
  val constant mAX'  : int16
end
module Core_Num_Impl1_Max
  use prelude.Int
  use prelude.Int16
  let constant mAX'  : int16 = [@vc:do_not_keep_trace] [@vc:sp]
    (32767 : int16)
end
module Creusot_SwapEnums_Interface
  use prelude.Int
  use prelude.Borrow
  use prelude.Int16
  clone Core_Num_Impl1_Max_Stub as Max0
  use Creusot_OptionCustom_Type as Creusot_OptionCustom_Type
  val swap_enums [#"/all/creusot.rs" 574 0 574 47] (i : Creusot_OptionCustom_Type.t_optioncustom) : Creusot_OptionCustom_Type.t_optioncustom
    requires {[#"/all/creusot.rs" 565 11 568 1] match (i) with
      | Creusot_OptionCustom_Type.C_Left left -> left < Max0.mAX'
      | Creusot_OptionCustom_Type.C_Right right -> right < Max0.mAX'
      end}
    ensures { [#"/all/creusot.rs" 569 10 573 1] match ((i, result)) with
      | (Creusot_OptionCustom_Type.C_Left left, Creusot_OptionCustom_Type.C_Right right) -> left + (1 : int16) = right
      | (Creusot_OptionCustom_Type.C_Right right, Creusot_OptionCustom_Type.C_Left left) -> left = right + (1 : int16)
      | _ -> false
      end }
    
end
module Creusot_SwapEnums
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use prelude.Int16
  clone Core_Num_Impl1_Max as Max0
  use Creusot_OptionCustom_Type as Creusot_OptionCustom_Type
  let rec cfg swap_enums [#"/all/creusot.rs" 574 0 574 47] [@cfg:stackify] [@cfg:subregion_analysis] (i : Creusot_OptionCustom_Type.t_optioncustom) : Creusot_OptionCustom_Type.t_optioncustom
    requires {[#"/all/creusot.rs" 565 11 568 1] match (i) with
      | Creusot_OptionCustom_Type.C_Left left -> left < Max0.mAX'
      | Creusot_OptionCustom_Type.C_Right right -> right < Max0.mAX'
      end}
    ensures { [#"/all/creusot.rs" 569 10 573 1] match ((i, result)) with
      | (Creusot_OptionCustom_Type.C_Left left, Creusot_OptionCustom_Type.C_Right right) -> left + (1 : int16) = right
      | (Creusot_OptionCustom_Type.C_Right right, Creusot_OptionCustom_Type.C_Left left) -> left = right + (1 : int16)
      | _ -> false
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_OptionCustom_Type.t_optioncustom;
  var i_1 : Creusot_OptionCustom_Type.t_optioncustom;
  var _4 : isize;
  var left_5 : int16;
  var de_6 : int16;
  var _7 : int16;
  var _8 : int16;
  var right_9 : int16;
  var de_10 : int16;
  var _11 : int16;
  var _12 : int16;
  {
    i_1 <- i;
    goto BB0
  }
  BB0 {
    switch (i_1)
      | Creusot_OptionCustom_Type.C_Left _ -> goto BB3
      | Creusot_OptionCustom_Type.C_Right _ -> goto BB1
      end
  }
  BB1 {
    right_9 <- Creusot_OptionCustom_Type.right_right i_1;
    de_10 <- right_9;
    _12 <- de_10;
    _11 <- ([#"/all/creusot.rs" 582 33 582 41] _12 + ([#"/all/creusot.rs" 582 39 582 40] (1 : int16)));
    _0 <- Creusot_OptionCustom_Type.C_Left _11;
    goto BB4
  }
  BB2 {
    absurd
  }
  BB3 {
    left_5 <- Creusot_OptionCustom_Type.left_left i_1;
    de_6 <- left_5;
    _8 <- de_6;
    _7 <- ([#"/all/creusot.rs" 578 35 578 43] _8 + ([#"/all/creusot.rs" 578 41 578 42] (1 : int16)));
    _0 <- Creusot_OptionCustom_Type.C_Right _7;
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Creusot_FindFalse_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  val find_false [#"/all/creusot.rs" 589 0 589 26] (x : borrowed int32) : ()
    requires {[#"/all/creusot.rs" 587 11 587 22]  ^ x = (1 : int32)}
    ensures { [#"/all/creusot.rs" 588 10 588 23]  * x = (999 : int32) }
    
end
module Creusot_FindFalse
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  let rec cfg find_false [#"/all/creusot.rs" 589 0 589 26] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed int32) : ()
    requires {[#"/all/creusot.rs" 587 11 587 22]  ^ x = (1 : int32)}
    ensures { [#"/all/creusot.rs" 588 10 588 23]  * x = (999 : int32) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed int32;
  var _4 : int32;
  var _5 : ();
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _4 <- ([#"/all/creusot.rs" 590 7 590 8] (0 : int32));
    x_1 <- { x_1 with current = _4 };
    _4 <- any int32;
    assume { Resolve0.resolve x_1 };
    absurd
  }
  
end
module Creusot_RbrrwChoice_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  val rbrrw_choice [#"/all/creusot.rs" 597 0 597 85] (left : borrowed int32) (right : borrowed int32) (cond : bool) : borrowed int32
    ensures { [#"/all/creusot.rs" 594 0 596 2] if cond then
      left = result /\  * right =  ^ right
    else
      right = result /\  * left =  ^ left
     }
    
end
module Creusot_RbrrwChoice
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  let rec cfg rbrrw_choice [#"/all/creusot.rs" 597 0 597 85] [@cfg:stackify] [@cfg:subregion_analysis] (left : borrowed int32) (right : borrowed int32) (cond : bool) : borrowed int32
    ensures { [#"/all/creusot.rs" 594 0 596 2] if cond then
      left = result /\  * right =  ^ right
    else
      right = result /\  * left =  ^ left
     }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed int32;
  var left_1 : borrowed int32;
  var right_2 : borrowed int32;
  var cond_3 : bool;
  var _4 : borrowed int32;
  var _6 : borrowed int32;
  var _7 : bool;
  var _8 : borrowed int32;
  {
    left_1 <- left;
    right_2 <- right;
    cond_3 <- cond;
    goto BB0
  }
  BB0 {
    _7 <- cond_3;
    switch (_7)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    assume { Resolve0.resolve right_2 };
    _8 <- borrow_mut ( * left_1);
    left_1 <- { left_1 with current = ( ^ _8) };
    assume { Resolve0.resolve left_1 };
    _6 <- borrow_mut ( * _8);
    _8 <- { _8 with current = ( ^ _6) };
    assume { Resolve0.resolve _8 };
    goto BB3
  }
  BB2 {
    assume { Resolve0.resolve left_1 };
    _6 <- borrow_mut ( * right_2);
    right_2 <- { right_2 with current = ( ^ _6) };
    assume { Resolve0.resolve right_2 };
    goto BB3
  }
  BB3 {
    _4 <- borrow_mut ( * _6);
    _6 <- { _6 with current = ( ^ _4) };
    assume { Resolve0.resolve _6 };
    _0 <- borrow_mut ( * _4);
    _4 <- { _4 with current = ( ^ _0) };
    assume { Resolve0.resolve _4 };
    return _0
  }
  
end
module Creusot_Common_Type
  use prelude.Int
  use prelude.UInt8
  use prelude.Int32
  type t_common  =
    | C_Common uint8 int32
    
  let function common_f4 (self : t_common) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Common _ a -> a
      end
end
module Creusot_Enum_Type
  use prelude.Int
  use prelude.Int32
  use Creusot_Common_Type as Creusot_Common_Type
  type t_enum  =
    | C_V1 (Creusot_Common_Type.t_common)
    | C_V2 int32 (Creusot_Common_Type.t_common)
    
  let function v2_f6 (self : t_enum) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_V1 _ -> any int32
      | C_V2 a _ -> a
      end
  let function v2_f7 (self : t_enum) : Creusot_Common_Type.t_common = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_V1 _ -> any Creusot_Common_Type.t_common
      | C_V2 _ a -> a
      end
end
module Creusot_Start_Type
  use Creusot_Enum_Type as Creusot_Enum_Type
  type t_start  =
    | C_Start (Creusot_Enum_Type.t_enum)
    
  let function start_z (self : t_start) : Creusot_Enum_Type.t_enum = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Start a -> a
      end
end
module Creusot_End_Type
  use prelude.Int
  use prelude.Int32
  use Creusot_Common_Type as Creusot_Common_Type
  type t_end  =
    | C_End int32 (Creusot_Common_Type.t_common)
    
  let function end_x (self : t_end) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_End a _ -> a
      end
end
module Creusot_Rearrange_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Creusot_End_Type as Creusot_End_Type
  use Creusot_Start_Type as Creusot_Start_Type
  use Creusot_Common_Type as Creusot_Common_Type
  use Creusot_Enum_Type as Creusot_Enum_Type
  val rearrange [#"/all/creusot.rs" 611 0 611 45] (i : borrowed (Creusot_Common_Type.t_common)) (x : Creusot_Start_Type.t_start) : Creusot_End_Type.t_end
    requires {[#"/all/creusot.rs" 606 11 606 84] match (Creusot_Start_Type.start_z x) with
      | Creusot_Enum_Type.C_V2 f6 _ -> f6 >= Creusot_Common_Type.common_f4 ( * i) /\ Int32.to_int (Creusot_Common_Type.common_f4 ( * i)) >= 0
      | _ -> false
      end}
    ensures { [#"/all/creusot.rs" 607 10 610 1] match (Creusot_Start_Type.start_z x) with
      | Creusot_Enum_Type.C_V1 _ -> true
      | Creusot_Enum_Type.C_V2 f6 _ -> Creusot_End_Type.end_x result = f6 - Creusot_Common_Type.common_f4 ( * i)
      end }
    
end
module Creusot_Rearrange
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use prelude.IntSize
  use Creusot_Common_Type as Creusot_Common_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Common_Type.t_common
  use Creusot_Enum_Type as Creusot_Enum_Type
  use Creusot_Start_Type as Creusot_Start_Type
  use Creusot_End_Type as Creusot_End_Type
  let rec cfg rearrange [#"/all/creusot.rs" 611 0 611 45] [@cfg:stackify] [@cfg:subregion_analysis] (i : borrowed (Creusot_Common_Type.t_common)) (x : Creusot_Start_Type.t_start) : Creusot_End_Type.t_end
    requires {[#"/all/creusot.rs" 606 11 606 84] match (Creusot_Start_Type.start_z x) with
      | Creusot_Enum_Type.C_V2 f6 _ -> f6 >= Creusot_Common_Type.common_f4 ( * i) /\ Int32.to_int (Creusot_Common_Type.common_f4 ( * i)) >= 0
      | _ -> false
      end}
    ensures { [#"/all/creusot.rs" 607 10 610 1] match (Creusot_Start_Type.start_z x) with
      | Creusot_Enum_Type.C_V1 _ -> true
      | Creusot_Enum_Type.C_V2 f6 _ -> Creusot_End_Type.end_x result = f6 - Creusot_Common_Type.common_f4 ( * i)
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_End_Type.t_end;
  var i_1 : borrowed (Creusot_Common_Type.t_common);
  var x_2 : Creusot_Start_Type.t_start;
  var de_5 : int32;
  var _6 : isize;
  var _7 : ();
  var f6_8 : int32;
  var f7_9 : Creusot_Common_Type.t_common;
  var _10 : int32;
  var _11 : int32;
  var _12 : int32;
  var _13 : Creusot_Common_Type.t_common;
  {
    i_1 <- i;
    x_2 <- x;
    goto BB0
  }
  BB0 {
    de_5 <- Creusot_Common_Type.common_f4 ( * i_1);
    assume { Resolve0.resolve i_1 };
    switch (Creusot_Start_Type.start_z x_2)
      | Creusot_Enum_Type.C_V1 _ -> goto BB3
      | Creusot_Enum_Type.C_V2 _ _ -> goto BB1
      end
  }
  BB1 {
    f6_8 <- Creusot_Enum_Type.v2_f6 (Creusot_Start_Type.start_z x_2);
    f7_9 <- Creusot_Enum_Type.v2_f7 (Creusot_Start_Type.start_z x_2);
    x_2 <- (let Creusot_Start_Type.C_Start a = x_2 in Creusot_Start_Type.C_Start (let Creusot_Enum_Type.C_V2 a b = Creusot_Start_Type.start_z x_2 in Creusot_Enum_Type.C_V2 a (any Creusot_Common_Type.t_common)));
    _11 <- f6_8;
    _12 <- de_5;
    _10 <- ([#"/all/creusot.rs" 615 36 615 45] _11 - _12);
    _13 <- f7_9;
    f7_9 <- any Creusot_Common_Type.t_common;
    _0 <- Creusot_End_Type.C_End _10 _13;
    return _0
  }
  BB2 {
    absurd
  }
  BB3 {
    absurd
  }
  
end
module Creusot_NodeSll_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  type t_nodesll 't =
    | C_NodeSLL 't (Core_Option_Option_Type.t_option (t_nodesll 't))
    
  let function nodesll_next (self : t_nodesll 't) : Core_Option_Option_Type.t_option (t_nodesll 't)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_NodeSLL _ a -> a
      end
  let function nodesll_elem (self : t_nodesll 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_NodeSLL a _ -> a
      end
end
module Creusot_Impl9_Len_Stub
  type t
  use prelude.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function len [#"/all/creusot.rs" 639 4 639 34] (self : Creusot_NodeSll_Type.t_nodesll t) : int
end
module Creusot_Impl9_Len_Interface
  type t
  use prelude.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function len [#"/all/creusot.rs" 639 4 639 34] (self : Creusot_NodeSll_Type.t_nodesll t) : int
  axiom len_spec : forall self : Creusot_NodeSll_Type.t_nodesll t . ([#"/all/creusot.rs" 638 14 638 25] len self >= 1) && ([#"/all/creusot.rs" 634 14 637 7] len self = 1 + match (Creusot_NodeSll_Type.nodesll_next self) with
    | Core_Option_Option_Type.C_None -> 0
    | Core_Option_Option_Type.C_Some n -> len n
    end)
end
module Creusot_Impl9_Len
  type t
  use prelude.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function len [#"/all/creusot.rs" 639 4 639 34] (self : Creusot_NodeSll_Type.t_nodesll t) : int
  val len [#"/all/creusot.rs" 639 4 639 34] (self : Creusot_NodeSll_Type.t_nodesll t) : int
    ensures { result = len self }
    
  axiom len_spec : forall self : Creusot_NodeSll_Type.t_nodesll t . ([#"/all/creusot.rs" 638 14 638 25] len self >= 1) && ([#"/all/creusot.rs" 634 14 637 7] len self = 1 + match (Creusot_NodeSll_Type.nodesll_next self) with
    | Core_Option_Option_Type.C_None -> 0
    | Core_Option_Option_Type.C_Some n -> len n
    end)
end
module Creusot_ListSll_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  type t_listsll 't =
    | C_ListSLL (Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll 't))
    
  let function listsll_head (self : t_listsll 't) : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll 't)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_ListSLL a -> a
      end
end
module Creusot_Impl10_Len_Stub
  type t
  use prelude.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_Impl9_Len_Stub as Len0 with
    type t = t,
    axiom .
  function len [#"/all/creusot.rs" 660 4 660 34] (self : Creusot_ListSll_Type.t_listsll t) : int
end
module Creusot_Impl10_Len_Interface
  type t
  use prelude.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_Impl9_Len_Stub as Len0 with
    type t = t,
    axiom .
  function len [#"/all/creusot.rs" 660 4 660 34] (self : Creusot_ListSll_Type.t_listsll t) : int
  axiom len_spec : forall self : Creusot_ListSll_Type.t_listsll t . [#"/all/creusot.rs" 655 14 658 6] len self = match (Creusot_ListSll_Type.listsll_head self) with
    | Core_Option_Option_Type.C_None -> 0
    | Core_Option_Option_Type.C_Some n -> Len0.len n
    end
end
module Creusot_Impl10_Len
  type t
  use prelude.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_Impl9_Len_Stub as Len0 with
    type t = t,
    axiom .
  function len [#"/all/creusot.rs" 660 4 660 34] (self : Creusot_ListSll_Type.t_listsll t) : int
  val len [#"/all/creusot.rs" 660 4 660 34] (self : Creusot_ListSll_Type.t_listsll t) : int
    ensures { result = len self }
    
  axiom len_spec : forall self : Creusot_ListSll_Type.t_listsll t . [#"/all/creusot.rs" 655 14 658 6] len self = match (Creusot_ListSll_Type.listsll_head self) with
    | Core_Option_Option_Type.C_None -> 0
    | Core_Option_Option_Type.C_Some n -> Len0.len n
    end
end
module Creusot_Impl10_New_Interface
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_Impl9_Len_Stub as Len1 with
    type t = t,
    axiom .
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  clone Creusot_Impl10_Len_Stub as Len0 with
    type t = t,
    function Len0.len = Len1.len,
    axiom .
  val new [#"/all/creusot.rs" 649 4 649 24] (_1' : ()) : Creusot_ListSll_Type.t_listsll t
    ensures { [#"/all/creusot.rs" 648 14 648 31] Len0.len result = 0 }
    
end
module Creusot_Impl10_New
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_Impl9_Len as Len1 with
    type t = t,
    axiom .
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  clone Creusot_Impl10_Len as Len0 with
    type t = t,
    function Len0.len = Len1.len,
    axiom .
  let rec cfg new [#"/all/creusot.rs" 649 4 649 24] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : Creusot_ListSll_Type.t_listsll t
    ensures { [#"/all/creusot.rs" 648 14 648 31] Len0.len result = 0 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_ListSll_Type.t_listsll t;
  var _2 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  {
    goto BB0
  }
  BB0 {
    _2 <- Core_Option_Option_Type.C_None;
    _0 <- Creusot_ListSll_Type.C_ListSLL _2;
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module Creusot_IsNone_Stub
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  function is_none [#"/all/creusot.rs" 1765 0 1765 37] (opt : Core_Option_Option_Type.t_option t) : bool
end
module Creusot_IsNone_Interface
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  function is_none [#"/all/creusot.rs" 1765 0 1765 37] (opt : Core_Option_Option_Type.t_option t) : bool
end
module Creusot_IsNone
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  function is_none [#"/all/creusot.rs" 1765 0 1765 37] (opt : Core_Option_Option_Type.t_option t) : bool =
    [#"/all/creusot.rs" 1766 2 1766 40] match (opt) with
      | Core_Option_Option_Type.C_None -> true
      | _ -> false
      end
  val is_none [#"/all/creusot.rs" 1765 0 1765 37] (opt : Core_Option_Option_Type.t_option t) : bool
    ensures { result = is_none opt }
    
end
module Creusot_Take_Interface
  type t
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_IsNone_Stub as IsNone0 with
    type t = t
  val take [#"/all/creusot.rs" 1753 0 1753 42] (x : borrowed (Core_Option_Option_Type.t_option t)) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 1751 10 1751 21] IsNone0.is_none ( ^ x) }
    ensures { [#"/all/creusot.rs" 1752 10 1752 22]  * x = result }
    
end
module Creusot_Impl10_Push_Interface
  type t
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  val push [#"/all/creusot.rs" 674 4 674 35] (self : borrowed (Creusot_ListSll_Type.t_listsll t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 669 14 673 5] match (Creusot_ListSll_Type.listsll_head ( ^ self)) with
      | Core_Option_Option_Type.C_Some node -> Creusot_NodeSll_Type.nodesll_next node = Creusot_ListSll_Type.listsll_head ( * self)
      | Core_Option_Option_Type.C_None -> false
      end }
    
end
module Creusot_Impl10_Push
  type t
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone Creusot_IsNone as IsNone0 with
    type t = Creusot_NodeSll_Type.t_nodesll t
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve5 with
    type t = Creusot_ListSll_Type.t_listsll t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Creusot_NodeSll_Type.t_nodesll t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Creusot_NodeSll_Type.t_nodesll t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = t
  clone Creusot_Take_Interface as Take0 with
    type t = Creusot_NodeSll_Type.t_nodesll t,
    function IsNone0.is_none = IsNone0.is_none
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)
  let rec cfg push [#"/all/creusot.rs" 674 4 674 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_ListSll_Type.t_listsll t)) (elem : t) : ()
    ensures { [#"/all/creusot.rs" 669 14 673 5] match (Creusot_ListSll_Type.listsll_head ( ^ self)) with
      | Core_Option_Option_Type.C_Some node -> Creusot_NodeSll_Type.nodesll_next node = Creusot_ListSll_Type.listsll_head ( * self)
      | Core_Option_Option_Type.C_None -> false
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_ListSll_Type.t_listsll t);
  var elem_2 : t;
  var result_4 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _5 : borrowed (Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t));
  var _6 : borrowed (Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t));
  var bx_7 : Creusot_NodeSll_Type.t_nodesll t;
  var _8 : t;
  var _9 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _0_10 : Creusot_NodeSll_Type.t_nodesll t;
  var _11 : Creusot_NodeSll_Type.t_nodesll t;
  var new_12 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _13 : Creusot_NodeSll_Type.t_nodesll t;
  var _14 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  {
    self_1 <- self;
    elem_2 <- elem;
    goto BB0
  }
  BB0 {
    _6 <- borrow_mut (Creusot_ListSll_Type.listsll_head ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_ListSll_Type.C_ListSLL a =  * self_1 in Creusot_ListSll_Type.C_ListSLL ( ^ _6)) };
    _5 <- borrow_mut ( * _6);
    _6 <- { _6 with current = ( ^ _5) };
    assume { Resolve0.resolve _6 };
    result_4 <- ([#"/all/creusot.rs" 675 19 675 39] Take0.take _5);
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve _8 };
    _8 <- elem_2;
    elem_2 <- any t;
    assume { Resolve2.resolve _9 };
    _9 <- result_4;
    result_4 <- any Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
    bx_7 <- Creusot_NodeSll_Type.C_NodeSLL _8 _9;
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    assume { Resolve3.resolve _11 };
    _11 <- bx_7;
    bx_7 <- any Creusot_NodeSll_Type.t_nodesll t;
    _0_10 <- _11;
    goto BB4
  }
  BB4 {
    assume { Resolve4.resolve _13 };
    _13 <- _0_10;
    _0_10 <- any Creusot_NodeSll_Type.t_nodesll t;
    new_12 <- Core_Option_Option_Type.C_Some _13;
    goto BB5
  }
  BB5 {
    assume { Resolve2.resolve _14 };
    _14 <- new_12;
    new_12 <- any Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
    goto BB6
  }
  BB6 {
    assume { Resolve2.resolve (Creusot_ListSll_Type.listsll_head ( * self_1)) };
    self_1 <- { self_1 with current = (let Creusot_ListSll_Type.C_ListSLL a =  * self_1 in Creusot_ListSll_Type.C_ListSLL _14) };
    _14 <- any Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
    assume { Resolve5.resolve self_1 };
    _0 <- ();
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Creusot_Impl10_Pop_Interface
  type t
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  val pop [#"/all/creusot.rs" 692 4 692 38] (self : borrowed (Creusot_ListSll_Type.t_listsll t)) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 688 14 691 5] match (Creusot_ListSll_Type.listsll_head ( * self)) with
      | Core_Option_Option_Type.C_Some node -> Creusot_ListSll_Type.listsll_head ( ^ self) = Creusot_NodeSll_Type.nodesll_next node
      | Core_Option_Option_Type.C_None -> true
      end }
    
end
module Creusot_Impl10_Pop
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone Creusot_IsNone as IsNone0 with
    type t = Creusot_NodeSll_Type.t_nodesll t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = Core_Option_Option_Type.t_option t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Creusot_NodeSll_Type.t_nodesll t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Creusot_ListSll_Type.t_listsll t
  clone Creusot_Take_Interface as Take0 with
    type t = Creusot_NodeSll_Type.t_nodesll t,
    function IsNone0.is_none = IsNone0.is_none
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)
  let rec cfg pop [#"/all/creusot.rs" 692 4 692 38] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_ListSll_Type.t_listsll t)) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 688 14 691 5] match (Creusot_ListSll_Type.listsll_head ( * self)) with
      | Core_Option_Option_Type.C_Some node -> Creusot_ListSll_Type.listsll_head ( ^ self) = Creusot_NodeSll_Type.nodesll_next node
      | Core_Option_Option_Type.C_None -> true
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option t;
  var self_1 : borrowed (Creusot_ListSll_Type.t_listsll t);
  var result_3 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _4 : borrowed (Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t));
  var _5 : borrowed (Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t));
  var _6 : isize;
  var _0_7 : Creusot_NodeSll_Type.t_nodesll t;
  var result_8 : Core_Option_Option_Type.t_option t;
  var _9 : t;
  var _10 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Creusot_ListSll_Type.listsll_head ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_ListSll_Type.C_ListSLL a =  * self_1 in Creusot_ListSll_Type.C_ListSLL ( ^ _5)) };
    _4 <- borrow_mut ( * _5);
    _5 <- { _5 with current = ( ^ _4) };
    assume { Resolve0.resolve _5 };
    result_3 <- ([#"/all/creusot.rs" 693 19 693 39] Take0.take _4);
    goto BB1
  }
  BB1 {
    switch (result_3)
      | Core_Option_Option_Type.C_None -> goto BB4
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      end
  }
  BB2 {
    assume { Resolve3.resolve _0_7 };
    _0_7 <- Core_Option_Option_Type.some_0 result_3;
    result_3 <- (let Core_Option_Option_Type.C_Some a = result_3 in Core_Option_Option_Type.C_Some (any Creusot_NodeSll_Type.t_nodesll t));
    assume { Resolve2.resolve result_3 };
    assume { Resolve4.resolve _9 };
    _9 <- Creusot_NodeSll_Type.nodesll_elem _0_7;
    _0_7 <- (let Creusot_NodeSll_Type.C_NodeSLL a b = _0_7 in Creusot_NodeSll_Type.C_NodeSLL (any t) b);
    result_8 <- Core_Option_Option_Type.C_Some _9;
    goto BB5
  }
  BB3 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve result_3 };
    absurd
  }
  BB4 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve result_3 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB11
  }
  BB5 {
    assume { Resolve2.resolve _10 };
    _10 <- Creusot_NodeSll_Type.nodesll_next _0_7;
    _0_7 <- (let Creusot_NodeSll_Type.C_NodeSLL a b = _0_7 in Creusot_NodeSll_Type.C_NodeSLL a (any Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)));
    assume { Resolve3.resolve _0_7 };
    goto BB6
  }
  BB6 {
    assume { Resolve2.resolve (Creusot_ListSll_Type.listsll_head ( * self_1)) };
    self_1 <- { self_1 with current = (let Creusot_ListSll_Type.C_ListSLL a =  * self_1 in Creusot_ListSll_Type.C_ListSLL _10) };
    _10 <- any Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
    assume { Resolve1.resolve self_1 };
    goto BB8
  }
  BB8 {
    assume { Resolve5.resolve _0 };
    _0 <- result_8;
    result_8 <- any Core_Option_Option_Type.t_option t;
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    return _0
  }
  
end
module Creusot_Impl10_Peek_Interface
  type t
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_IsSome_Stub as IsSome1 with
    type t = t
  clone Creusot_IsSome_Stub as IsSome0 with
    type t = Creusot_NodeSll_Type.t_nodesll t
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  val peek [#"/all/creusot.rs" 711 4 711 36] (self : Creusot_ListSll_Type.t_listsll t) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 710 14 710 51] IsSome0.is_some (Creusot_ListSll_Type.listsll_head self) = IsSome1.is_some result }
    
end
module Creusot_Impl10_Peek
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Creusot_NodeSll_Type.t_nodesll t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_ListSll_Type.t_listsll t
  clone Creusot_IsSome as IsSome1 with
    type t = t
  clone Creusot_IsSome as IsSome0 with
    type t = Creusot_NodeSll_Type.t_nodesll t
  let rec cfg peek [#"/all/creusot.rs" 711 4 711 36] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_ListSll_Type.t_listsll t) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 710 14 710 51] IsSome0.is_some (Creusot_ListSll_Type.listsll_head self) = IsSome1.is_some result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option t;
  var self_1 : Creusot_ListSll_Type.t_listsll t;
  var _3 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _4 : isize;
  var _0_5 : Creusot_NodeSll_Type.t_nodesll t;
  var _6 : t;
  var _7 : t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _3 <- Creusot_ListSll_Type.listsll_head self_1;
    assume { Resolve0.resolve self_1 };
    switch (_3)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB1
      end
  }
  BB1 {
    _0_5 <- Core_Option_Option_Type.some_0 _3;
    assume { Resolve1.resolve _3 };
    _7 <- Creusot_NodeSll_Type.nodesll_elem _0_5;
    assume { Resolve2.resolve _0_5 };
    _6 <- _7;
    assume { Resolve3.resolve _7 };
    _0 <- Core_Option_Option_Type.C_Some _6;
    goto BB4
  }
  BB2 {
    assume { Resolve1.resolve _3 };
    absurd
  }
  BB3 {
    assume { Resolve1.resolve _3 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Creusot_Impl10_PeekMut_Interface
  type t
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  val peek_mut [#"/all/creusot.rs" 725 4 725 48] (self : borrowed (Creusot_ListSll_Type.t_listsll t)) : Core_Option_Option_Type.t_option (borrowed t)
    ensures { [#"/all/creusot.rs" 719 14 724 5] match ((Creusot_ListSll_Type.listsll_head ( * self), result, Creusot_ListSll_Type.listsll_head ( ^ self))) with
      | (Core_Option_Option_Type.C_Some node, Core_Option_Option_Type.C_Some v, Core_Option_Option_Type.C_Some fut) -> Creusot_NodeSll_Type.nodesll_elem node =  * v /\  ^ v = Creusot_NodeSll_Type.nodesll_elem fut
      | (Core_Option_Option_Type.C_None, Core_Option_Option_Type.C_None, Core_Option_Option_Type.C_None) -> true
      | _ -> false
      end }
    
end
module Creusot_Impl10_PeekMut
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Creusot_NodeSll_Type.t_nodesll t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)
  use Creusot_ListSll_Type as Creusot_ListSll_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_ListSll_Type.t_listsll t
  let rec cfg peek_mut [#"/all/creusot.rs" 725 4 725 48] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_ListSll_Type.t_listsll t)) : Core_Option_Option_Type.t_option (borrowed t)
    ensures { [#"/all/creusot.rs" 719 14 724 5] match ((Creusot_ListSll_Type.listsll_head ( * self), result, Creusot_ListSll_Type.listsll_head ( ^ self))) with
      | (Core_Option_Option_Type.C_Some node, Core_Option_Option_Type.C_Some v, Core_Option_Option_Type.C_Some fut) -> Creusot_NodeSll_Type.nodesll_elem node =  * v /\  ^ v = Creusot_NodeSll_Type.nodesll_elem fut
      | (Core_Option_Option_Type.C_None, Core_Option_Option_Type.C_None, Core_Option_Option_Type.C_None) -> true
      | _ -> false
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (borrowed t);
  var self_1 : borrowed (Creusot_ListSll_Type.t_listsll t);
  var _3 : borrowed (Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t));
  var _4 : isize;
  var _0_5 : borrowed (Creusot_NodeSll_Type.t_nodesll t);
  var _6 : borrowed t;
  var _7 : borrowed t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _3 <- borrow_mut (Creusot_ListSll_Type.listsll_head ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_ListSll_Type.C_ListSLL a =  * self_1 in Creusot_ListSll_Type.C_ListSLL ( ^ _3)) };
    assume { Resolve0.resolve self_1 };
    switch ( * _3)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB1
      end
  }
  BB1 {
    _0_5 <- borrow_mut (Core_Option_Option_Type.some_0 ( * _3));
    _3 <- { _3 with current = (let Core_Option_Option_Type.C_Some a =  * _3 in Core_Option_Option_Type.C_Some ( ^ _0_5)) };
    assume { Resolve1.resolve _3 };
    _7 <- borrow_mut (Creusot_NodeSll_Type.nodesll_elem ( * _0_5));
    _0_5 <- { _0_5 with current = (let Creusot_NodeSll_Type.C_NodeSLL a b =  * _0_5 in Creusot_NodeSll_Type.C_NodeSLL ( ^ _7) b) };
    assume { Resolve2.resolve _0_5 };
    _6 <- borrow_mut ( * _7);
    _7 <- { _7 with current = ( ^ _6) };
    assume { Resolve3.resolve _7 };
    _0 <- Core_Option_Option_Type.C_Some _6;
    goto BB4
  }
  BB2 {
    assume { Resolve1.resolve _3 };
    absurd
  }
  BB3 {
    assume { Resolve1.resolve _3 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Creusot_Iter_Type
  use prelude.Borrow
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  type t_iter 't =
    | C_Iter (Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll 't))
    
  let function iter_next (self : t_iter 't) : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll 't)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Iter a -> a
      end
end
module Creusot_Impl11_Len_Stub
  type t
  use prelude.Int
  use Creusot_Iter_Type as Creusot_Iter_Type
  function len [#"/all/creusot.rs" 737 4 737 34] (self : Creusot_Iter_Type.t_iter t) : int
end
module Creusot_Impl11_Len_Interface
  type t
  use prelude.Int
  use Creusot_Iter_Type as Creusot_Iter_Type
  function len [#"/all/creusot.rs" 737 4 737 34] (self : Creusot_Iter_Type.t_iter t) : int
end
module Creusot_Impl11_Len
  type t
  use prelude.Int
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_Impl9_Len_Stub as Len0 with
    type t = t,
    axiom .
  use Creusot_Iter_Type as Creusot_Iter_Type
  function len [#"/all/creusot.rs" 737 4 737 34] (self : Creusot_Iter_Type.t_iter t) : int =
    [#"/all/creusot.rs" 738 8 741 9] match (Creusot_Iter_Type.iter_next self) with
      | Core_Option_Option_Type.C_None -> 0
      | Core_Option_Option_Type.C_Some n -> Len0.len n
      end
  val len [#"/all/creusot.rs" 737 4 737 34] (self : Creusot_Iter_Type.t_iter t) : int
    ensures { result = len self }
    
end
module Creusot_Impl12_Next_Interface
  type t
  use prelude.Borrow
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Creusot_Iter_Type as Creusot_Iter_Type
  clone Creusot_IsSome_Stub as IsSome0 with
    type t = t
  clone Creusot_IsNone_Stub as IsNone0 with
    type t = t
  clone Creusot_Impl11_Len_Stub as Len0 with
    type t = t
  val next [#"/all/creusot.rs" 749 4 749 39] (self : borrowed (Creusot_Iter_Type.t_iter t)) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 746 4 748 6] if Len0.len ( * self) = 0 then
      Len0.len ( ^ self) = 0 /\ IsNone0.is_none result
    else
      Len0.len ( ^ self) = Len0.len ( * self) - 1 /\ IsSome0.is_some result
     }
    
end
module Creusot_Impl12_Next
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_Impl9_Len as Len1 with
    type t = t,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = Core_Option_Option_Type.t_option t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve7 with
    type t1 = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t),
    type t2 = Core_Option_Option_Type.t_option t,
    predicate Resolve0.resolve = Resolve5.resolve,
    predicate Resolve1.resolve = Resolve6.resolve
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Creusot_NodeSll_Type.t_nodesll t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Creusot_NodeSll_Type.t_nodesll t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t)
  use Creusot_Iter_Type as Creusot_Iter_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Iter_Type.t_iter t
  clone Creusot_IsSome as IsSome0 with
    type t = t
  clone Creusot_IsNone as IsNone0 with
    type t = t
  clone Creusot_Impl11_Len as Len0 with
    type t = t,
    function Len0.len = Len1.len
  let rec cfg next [#"/all/creusot.rs" 749 4 749 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Iter_Type.t_iter t)) : Core_Option_Option_Type.t_option t
    ensures { [#"/all/creusot.rs" 746 4 748 6] if Len0.len ( * self) = 0 then
      Len0.len ( ^ self) = 0 /\ IsNone0.is_none result
    else
      Len0.len ( ^ self) = Len0.len ( * self) - 1 /\ IsSome0.is_some result
     }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option t;
  var self_1 : borrowed (Creusot_Iter_Type.t_iter t);
  var new_3 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var result_4 : Core_Option_Option_Type.t_option t;
  var _5 : (Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t), Core_Option_Option_Type.t_option t);
  var _6 : borrowed (Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t));
  var _7 : isize;
  var _8 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _9 : Core_Option_Option_Type.t_option t;
  var _0_10 : borrowed (Creusot_NodeSll_Type.t_nodesll t);
  var _11 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _12 : isize;
  var result_13 : Core_Option_Option_Type.t_option t;
  var _14 : t;
  var _15 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _16 : Core_Option_Option_Type.t_option t;
  var _0_next_de_17 : Creusot_NodeSll_Type.t_nodesll t;
  var result_18 : Core_Option_Option_Type.t_option t;
  var _19 : t;
  var new_20 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _21 : Creusot_NodeSll_Type.t_nodesll t;
  var _22 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  var _23 : Core_Option_Option_Type.t_option t;
  var _24 : Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _6 <- borrow_mut (Creusot_Iter_Type.iter_next ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Iter_Type.C_Iter a =  * self_1 in Creusot_Iter_Type.C_Iter ( ^ _6)) };
    switch ( * _6)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB1
      end
  }
  BB1 {
    _0_10 <- borrow_mut (Core_Option_Option_Type.some_0 ( * _6));
    _6 <- { _6 with current = (let Core_Option_Option_Type.C_Some a =  * _6 in Core_Option_Option_Type.C_Some ( ^ _0_10)) };
    assume { Resolve1.resolve _6 };
    _11 <- Creusot_NodeSll_Type.nodesll_next ( * _0_10);
    switch (_11)
      | Core_Option_Option_Type.C_None -> goto BB6
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      end
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve _6 };
    absurd
  }
  BB3 {
    assume { Resolve1.resolve _6 };
    _8 <- Core_Option_Option_Type.C_None;
    _9 <- Core_Option_Option_Type.C_None;
    _5 <- (_8, _9);
    goto BB8
  }
  BB4 {
    _0_next_de_17 <- Core_Option_Option_Type.some_0 _11;
    assume { Resolve3.resolve _11 };
    _19 <- Creusot_NodeSll_Type.nodesll_elem ( * _0_10);
    assume { Resolve2.resolve _0_10 };
    result_18 <- Core_Option_Option_Type.C_Some _19;
    _21 <- _0_next_de_17;
    assume { Resolve4.resolve _0_next_de_17 };
    new_20 <- Core_Option_Option_Type.C_Some _21;
    assume { Resolve5.resolve _22 };
    _22 <- new_20;
    assume { Resolve5.resolve new_20 };
    assume { Resolve6.resolve _23 };
    _23 <- result_18;
    assume { Resolve6.resolve result_18 };
    _5 <- (_22, _23);
    goto BB7
  }
  BB5 {
    assume { Resolve0.resolve self_1 };
    assume { Resolve2.resolve _0_10 };
    assume { Resolve3.resolve _11 };
    absurd
  }
  BB6 {
    assume { Resolve3.resolve _11 };
    _14 <- Creusot_NodeSll_Type.nodesll_elem ( * _0_10);
    assume { Resolve2.resolve _0_10 };
    result_13 <- Core_Option_Option_Type.C_Some _14;
    _15 <- Core_Option_Option_Type.C_None;
    assume { Resolve6.resolve _16 };
    _16 <- result_13;
    assume { Resolve6.resolve result_13 };
    _5 <- (_15, _16);
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    assume { Resolve5.resolve new_3 };
    new_3 <- (let (a, _) = _5 in a);
    assume { Resolve6.resolve result_4 };
    result_4 <- (let (_, a) = _5 in a);
    assume { Resolve7.resolve _5 };
    assume { Resolve5.resolve _24 };
    _24 <- new_3;
    assume { Resolve5.resolve new_3 };
    assume { Resolve5.resolve (Creusot_Iter_Type.iter_next ( * self_1)) };
    self_1 <- { self_1 with current = (let Creusot_Iter_Type.C_Iter a =  * self_1 in Creusot_Iter_Type.C_Iter _24) };
    _24 <- any Core_Option_Option_Type.t_option (Creusot_NodeSll_Type.t_nodesll t);
    assume { Resolve0.resolve self_1 };
    assume { Resolve6.resolve _0 };
    _0 <- result_4;
    assume { Resolve6.resolve result_4 };
    return _0
  }
  
end
module Creusot_IterMut_Type
  use prelude.Borrow
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  type t_itermut 't =
    | C_IterMut (Core_Option_Option_Type.t_option (borrowed (Creusot_NodeSll_Type.t_nodesll 't)))
    
  let function itermut_next (self : t_itermut 't) : Core_Option_Option_Type.t_option (borrowed (Creusot_NodeSll_Type.t_nodesll 't))
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_IterMut a -> a
      end
end
module Creusot_Impl13_Len_Stub
  type t
  use prelude.Int
  use Creusot_IterMut_Type as Creusot_IterMut_Type
  function len [#"/all/creusot.rs" 773 4 773 34] (self : Creusot_IterMut_Type.t_itermut t) : int
end
module Creusot_Impl13_Len_Interface
  type t
  use prelude.Int
  use Creusot_IterMut_Type as Creusot_IterMut_Type
  function len [#"/all/creusot.rs" 773 4 773 34] (self : Creusot_IterMut_Type.t_itermut t) : int
end
module Creusot_Impl13_Len
  type t
  use prelude.Int
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_Impl9_Len_Stub as Len0 with
    type t = t,
    axiom .
  use Creusot_IterMut_Type as Creusot_IterMut_Type
  function len [#"/all/creusot.rs" 773 4 773 34] (self : Creusot_IterMut_Type.t_itermut t) : int =
    [#"/all/creusot.rs" 774 8 777 9] match (Creusot_IterMut_Type.itermut_next self) with
      | Core_Option_Option_Type.C_None -> 0
      | Core_Option_Option_Type.C_Some n -> Len0.len ( * n)
      end
  val len [#"/all/creusot.rs" 773 4 773 34] (self : Creusot_IterMut_Type.t_itermut t) : int
    ensures { result = len self }
    
end
module Creusot_Impl14_Next_Interface
  type t
  use prelude.Borrow
  use Creusot_IterMut_Type as Creusot_IterMut_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  val next [#"/all/creusot.rs" 787 4 787 43] (self : borrowed (Creusot_IterMut_Type.t_itermut t)) : Core_Option_Option_Type.t_option (borrowed t)
    ensures { [#"/all/creusot.rs" 782 14 786 5] match ((Creusot_IterMut_Type.itermut_next ( * self), result)) with
      | (Core_Option_Option_Type.C_None, Core_Option_Option_Type.C_None) -> true
      | (Core_Option_Option_Type.C_Some node, Core_Option_Option_Type.C_Some result) -> Creusot_NodeSll_Type.nodesll_elem ( ^ node) =  ^ result
      | _ -> false
      end }
    
end
module Creusot_Impl14_Next
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  clone Creusot_IsNone as IsNone0 with
    type t = borrowed (Creusot_NodeSll_Type.t_nodesll t)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve4 with
    type t = t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Creusot_NodeSll_Type.t_nodesll t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (borrowed (Creusot_NodeSll_Type.t_nodesll t))
  clone Creusot_Take_Interface as Take0 with
    type t = borrowed (Creusot_NodeSll_Type.t_nodesll t),
    function IsNone0.is_none = IsNone0.is_none
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Core_Option_Option_Type.t_option (borrowed (Creusot_NodeSll_Type.t_nodesll t))
  use Creusot_IterMut_Type as Creusot_IterMut_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_IterMut_Type.t_itermut t
  let rec cfg next [#"/all/creusot.rs" 787 4 787 43] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_IterMut_Type.t_itermut t)) : Core_Option_Option_Type.t_option (borrowed t)
    ensures { [#"/all/creusot.rs" 782 14 786 5] match ((Creusot_IterMut_Type.itermut_next ( * self), result)) with
      | (Core_Option_Option_Type.C_None, Core_Option_Option_Type.C_None) -> true
      | (Core_Option_Option_Type.C_Some node, Core_Option_Option_Type.C_Some result) -> Creusot_NodeSll_Type.nodesll_elem ( ^ node) =  ^ result
      | _ -> false
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (borrowed t);
  var self_1 : borrowed (Creusot_IterMut_Type.t_itermut t);
  var result_3 : Core_Option_Option_Type.t_option (borrowed (Creusot_NodeSll_Type.t_nodesll t));
  var _4 : borrowed (Core_Option_Option_Type.t_option (borrowed (Creusot_NodeSll_Type.t_nodesll t)));
  var _5 : borrowed (Core_Option_Option_Type.t_option (borrowed (Creusot_NodeSll_Type.t_nodesll t)));
  var _6 : isize;
  var _0_7 : borrowed (Creusot_NodeSll_Type.t_nodesll t);
  var _8 : borrowed t;
  var _9 : borrowed t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Creusot_IterMut_Type.itermut_next ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_IterMut_Type.C_IterMut a =  * self_1 in Creusot_IterMut_Type.C_IterMut ( ^ _5)) };
    assume { Resolve0.resolve self_1 };
    _4 <- borrow_mut ( * _5);
    _5 <- { _5 with current = ( ^ _4) };
    assume { Resolve1.resolve _5 };
    result_3 <- ([#"/all/creusot.rs" 788 19 788 39] Take0.take _4);
    goto BB1
  }
  BB1 {
    switch (result_3)
      | Core_Option_Option_Type.C_None -> goto BB4
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      end
  }
  BB2 {
    assume { Resolve3.resolve _0_7 };
    _0_7 <- Core_Option_Option_Type.some_0 result_3;
    result_3 <- (let Core_Option_Option_Type.C_Some a = result_3 in Core_Option_Option_Type.C_Some (any borrowed (Creusot_NodeSll_Type.t_nodesll t)));
    assume { Resolve2.resolve result_3 };
    _9 <- borrow_mut (Creusot_NodeSll_Type.nodesll_elem ( * _0_7));
    _0_7 <- { _0_7 with current = (let Creusot_NodeSll_Type.C_NodeSLL a b =  * _0_7 in Creusot_NodeSll_Type.C_NodeSLL ( ^ _9) b) };
    assume { Resolve3.resolve _0_7 };
    _8 <- borrow_mut ( * _9);
    _9 <- { _9 with current = ( ^ _8) };
    assume { Resolve4.resolve _9 };
    _0 <- Core_Option_Option_Type.C_Some _8;
    goto BB5
  }
  BB3 {
    assume { Resolve2.resolve result_3 };
    absurd
  }
  BB4 {
    assume { Resolve2.resolve result_3 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Creusot_Impl15_Sum_Stub
  use prelude.Int
  use prelude.Int32
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function sum [#"/all/creusot.rs" 804 4 804 23] (self : Creusot_NodeSll_Type.t_nodesll int32) : int32
end
module Creusot_Impl15_Sum_Interface
  use prelude.Int
  use prelude.Int32
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function sum [#"/all/creusot.rs" 804 4 804 23] (self : Creusot_NodeSll_Type.t_nodesll int32) : int32
  axiom sum_spec : forall self : Creusot_NodeSll_Type.t_nodesll int32 . [#"/all/creusot.rs" 800 14 803 6] sum self = match (Creusot_NodeSll_Type.nodesll_next self) with
    | Core_Option_Option_Type.C_None -> Creusot_NodeSll_Type.nodesll_elem self
    | Core_Option_Option_Type.C_Some next -> Creusot_NodeSll_Type.nodesll_elem self + sum next
    end
end
module Creusot_Impl15_Sum
  use prelude.Int
  use prelude.Int32
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_NodeSll_Type as Creusot_NodeSll_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function sum [#"/all/creusot.rs" 804 4 804 23] (self : Creusot_NodeSll_Type.t_nodesll int32) : int32
  val sum [#"/all/creusot.rs" 804 4 804 23] (self : Creusot_NodeSll_Type.t_nodesll int32) : int32
    ensures { result = sum self }
    
  axiom sum_spec : forall self : Creusot_NodeSll_Type.t_nodesll int32 . [#"/all/creusot.rs" 800 14 803 6] sum self = match (Creusot_NodeSll_Type.nodesll_next self) with
    | Core_Option_Option_Type.C_None -> Creusot_NodeSll_Type.nodesll_elem self
    | Core_Option_Option_Type.C_Some next -> Creusot_NodeSll_Type.nodesll_elem self + sum next
    end
end
module Creusot_Bar_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  type t_bar 't =
    | C_Bar (Core_Option_Option_Type.t_option 't)
    
  let function bar_data (self : t_bar 't) : Core_Option_Option_Type.t_option 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Bar a -> a
      end
end
module Core_Result_Result_Type
  type t_result 't 'e =
    | C_Ok 't
    | C_Err 'e
    
end
module Creusot_IsOk_Stub
  type t
  type e
  use Core_Result_Result_Type as Core_Result_Result_Type
  function is_ok [#"/all/creusot.rs" 1770 0 1770 39] (x : Core_Result_Result_Type.t_result t e) : bool
end
module Creusot_IsOk_Interface
  type t
  type e
  use Core_Result_Result_Type as Core_Result_Result_Type
  function is_ok [#"/all/creusot.rs" 1770 0 1770 39] (x : Core_Result_Result_Type.t_result t e) : bool
end
module Creusot_IsOk
  type t
  type e
  use Core_Result_Result_Type as Core_Result_Result_Type
  function is_ok [#"/all/creusot.rs" 1770 0 1770 39] (x : Core_Result_Result_Type.t_result t e) : bool =
    [#"/all/creusot.rs" 1771 4 1771 41] match (x) with
      | Core_Result_Result_Type.C_Ok _ -> true
      | _ -> false
      end
  val is_ok [#"/all/creusot.rs" 1770 0 1770 39] (x : Core_Result_Result_Type.t_result t e) : bool
    ensures { result = is_ok x }
    
end
module Creusot_Impl16_Borrow_Interface
  type t
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Creusot_IsOk_Stub as IsOk0 with
    type t = t,
    type e = ()
  clone Creusot_IsSome_Stub as IsSome0 with
    type t = t
  use Creusot_Bar_Type as Creusot_Bar_Type
  val borrow [#"/all/creusot.rs" 855 4 855 47] (self : borrowed (Creusot_Bar_Type.t_bar t)) : Core_Result_Result_Type.t_result t ()
    ensures { [#"/all/creusot.rs" 854 14 854 49] IsSome0.is_some (Creusot_Bar_Type.bar_data ( * self)) = IsOk0.is_ok result }
    
end
module Creusot_Impl16_Borrow
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Core_Option_Option_Type.t_option t
  use Creusot_Bar_Type as Creusot_Bar_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Bar_Type.t_bar t
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Creusot_IsOk as IsOk0 with
    type t = t,
    type e = ()
  clone Creusot_IsSome as IsSome0 with
    type t = t
  let rec cfg borrow [#"/all/creusot.rs" 855 4 855 47] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Bar_Type.t_bar t)) : Core_Result_Result_Type.t_result t ()
    ensures { [#"/all/creusot.rs" 854 14 854 49] IsSome0.is_some (Creusot_Bar_Type.bar_data ( * self)) = IsOk0.is_ok result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Result_Result_Type.t_result t ();
  var self_1 : borrowed (Creusot_Bar_Type.t_bar t);
  var _3 : borrowed (Core_Option_Option_Type.t_option t);
  var _4 : isize;
  var _5 : ();
  var _0_6 : borrowed t;
  var _7 : t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _3 <- borrow_mut (Creusot_Bar_Type.bar_data ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Bar_Type.C_Bar a =  * self_1 in Creusot_Bar_Type.C_Bar ( ^ _3)) };
    assume { Resolve0.resolve self_1 };
    switch ( * _3)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB1
      end
  }
  BB1 {
    _0_6 <- borrow_mut (Core_Option_Option_Type.some_0 ( * _3));
    _3 <- { _3 with current = (let Core_Option_Option_Type.C_Some a =  * _3 in Core_Option_Option_Type.C_Some ( ^ _0_6)) };
    assume { Resolve1.resolve _3 };
    _7 <-  * _0_6;
    assume { Resolve2.resolve _0_6 };
    _0 <- Core_Result_Result_Type.C_Ok _7;
    goto BB4
  }
  BB2 {
    assume { Resolve1.resolve _3 };
    absurd
  }
  BB3 {
    assume { Resolve1.resolve _3 };
    _5 <- ();
    _0 <- Core_Result_Result_Type.C_Err _5;
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Creusot_LinkedListNode_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  type t_linkedlistnode  =
    | C_LinkedListNode (Core_Option_Option_Type.t_option (t_linkedlistnode))
    
  let function linkedlistnode_next (self : t_linkedlistnode) : Core_Option_Option_Type.t_option (t_linkedlistnode)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedListNode a -> a
      end
end
module Creusot_LinkedList_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_LinkedListNode_Type as Creusot_LinkedListNode_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  type t_linkedlist  =
    | C_LinkedList (Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode))
    
  let function linkedlist_head (self : t_linkedlist) : Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedList a -> a
      end
end
module Creusot_Impl17_PrependValue_Interface
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_LinkedListNode_Type as Creusot_LinkedListNode_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Creusot_LinkedList_Type as Creusot_LinkedList_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  val prepend_value [#"/all/creusot.rs" 889 4 889 35] (self : borrowed (Creusot_LinkedList_Type.t_linkedlist)) : ()
    ensures { [#"/all/creusot.rs" 885 14 888 5] match (Creusot_LinkedList_Type.linkedlist_head ( ^ self)) with
      | Core_Option_Option_Type.C_None -> false
      | Core_Option_Option_Type.C_Some lln -> Creusot_LinkedListNode_Type.linkedlistnode_next lln = Creusot_LinkedList_Type.linkedlist_head ( * self)
      end }
    
end
module Creusot_Impl17_PrependValue
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_LinkedListNode_Type as Creusot_LinkedListNode_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  use Creusot_LinkedList_Type as Creusot_LinkedList_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Creusot_LinkedList_Type.t_linkedlist
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Creusot_Replace_Interface as Replace0 with
    type t = Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode)
  let rec cfg prepend_value [#"/all/creusot.rs" 889 4 889 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_LinkedList_Type.t_linkedlist)) : ()
    ensures { [#"/all/creusot.rs" 885 14 888 5] match (Creusot_LinkedList_Type.linkedlist_head ( ^ self)) with
      | Core_Option_Option_Type.C_None -> false
      | Core_Option_Option_Type.C_Some lln -> Creusot_LinkedListNode_Type.linkedlistnode_next lln = Creusot_LinkedList_Type.linkedlist_head ( * self)
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_LinkedList_Type.t_linkedlist);
  var result_3 : Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode);
  var _4 : borrowed (Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode));
  var _5 : borrowed (Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode));
  var _6 : Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode);
  var bx_7 : Creusot_LinkedListNode_Type.t_linkedlistnode;
  var _8 : Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode);
  var _0_9 : Creusot_LinkedListNode_Type.t_linkedlistnode;
  var _10 : Creusot_LinkedListNode_Type.t_linkedlistnode;
  var new_11 : Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode);
  var _12 : Creusot_LinkedListNode_Type.t_linkedlistnode;
  var _13 : Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Creusot_LinkedList_Type.linkedlist_head ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_LinkedList_Type.C_LinkedList a =  * self_1 in Creusot_LinkedList_Type.C_LinkedList ( ^ _5)) };
    _4 <- borrow_mut ( * _5);
    _5 <- { _5 with current = ( ^ _4) };
    assume { Resolve0.resolve _5 };
    _6 <- Core_Option_Option_Type.C_None;
    result_3 <- ([#"/all/creusot.rs" 890 19 890 48] Replace0.replace _4 _6);
    goto BB1
  }
  BB1 {
    _8 <- result_3;
    result_3 <- any Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode);
    bx_7 <- Creusot_LinkedListNode_Type.C_LinkedListNode _8;
    goto BB2
  }
  BB2 {
    _10 <- bx_7;
    bx_7 <- any Creusot_LinkedListNode_Type.t_linkedlistnode;
    _0_9 <- _10;
    goto BB3
  }
  BB3 {
    _12 <- _0_9;
    _0_9 <- any Creusot_LinkedListNode_Type.t_linkedlistnode;
    new_11 <- Core_Option_Option_Type.C_Some _12;
    goto BB4
  }
  BB4 {
    _13 <- new_11;
    new_11 <- any Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode);
    goto BB5
  }
  BB5 {
    self_1 <- { self_1 with current = (let Creusot_LinkedList_Type.C_LinkedList a =  * self_1 in Creusot_LinkedList_Type.C_LinkedList _13) };
    _13 <- any Core_Option_Option_Type.t_option (Creusot_LinkedListNode_Type.t_linkedlistnode);
    assume { Resolve1.resolve self_1 };
    _0 <- ();
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Creusot_IntSwap_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  val int_swap [#"/all/creusot.rs" 912 0 912 37] (x : borrowed int32) (y : borrowed int32) : ()
    ensures { [#"/all/creusot.rs" 910 10 910 18]  ^ x =  * y }
    ensures { [#"/all/creusot.rs" 911 10 911 18]  ^ y =  * x }
    
end
module Creusot_IntSwap
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  let rec cfg int_swap [#"/all/creusot.rs" 912 0 912 37] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed int32) (y : borrowed int32) : ()
    ensures { [#"/all/creusot.rs" 910 10 910 18]  ^ x =  * y }
    ensures { [#"/all/creusot.rs" 911 10 911 18]  ^ y =  * x }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed int32;
  var y_2 : borrowed int32;
  var de_y_5 : int32;
  var de_x_6 : int32;
  var _7 : int32;
  var _8 : int32;
  {
    x_1 <- x;
    y_2 <- y;
    goto BB0
  }
  BB0 {
    de_y_5 <-  * y_2;
    de_x_6 <-  * x_1;
    _7 <- de_y_5;
    x_1 <- { x_1 with current = _7 };
    _7 <- any int32;
    assume { Resolve0.resolve x_1 };
    _8 <- de_x_6;
    y_2 <- { y_2 with current = _8 };
    _8 <- any int32;
    assume { Resolve0.resolve y_2 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_Impl19_SllAppend_Interface
  type t
  use prelude.Borrow
  use prelude.Int
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = t,
    axiom .
  val sll_append [#"/all/creusot.rs" 946 4 946 38] (self : borrowed (Creusot_Node_Type.t_node t)) (tl : Creusot_Node_Type.t_node t) : ()
    ensures { [#"/all/creusot.rs" 945 14 945 55] Len0.len ( ^ self) = Len0.len ( * self) + Len0.len tl }
    
end
module Creusot_Impl19_SllAppend
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Node_Type.t_node t
  clone Creusot_Impl0_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg sll_append [#"/all/creusot.rs" 946 4 946 38] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Node_Type.t_node t)) (tl : Creusot_Node_Type.t_node t) : ()
    ensures { [#"/all/creusot.rs" 945 14 945 55] Len0.len ( ^ self) = Len0.len ( * self) + Len0.len tl }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_Node_Type.t_node t);
  var tl_2 : Creusot_Node_Type.t_node t;
  var _4 : isize;
  var _5 : Creusot_Node_Type.t_node t;
  var next_6 : borrowed (Creusot_Node_Type.t_node t);
  var _7 : borrowed (Creusot_Node_Type.t_node t);
  var _8 : Creusot_Node_Type.t_node t;
  {
    self_1 <- self;
    tl_2 <- tl;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    switch ( * self_1)
      | Creusot_Node_Type.C_Nil -> goto BB4
      | Creusot_Node_Type.C_Cons _ _ -> goto BB2
      end
  }
  BB2 {
    next_6 <- borrow_mut (Creusot_Node_Type.cons_next ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Node_Type.C_Cons a b =  * self_1 in Creusot_Node_Type.C_Cons a ( ^ next_6)) };
    assume { Resolve0.resolve self_1 };
    _7 <- borrow_mut ( * next_6);
    next_6 <- { next_6 with current = ( ^ _7) };
    assume { Resolve2.resolve next_6 };
    assume { Resolve1.resolve _8 };
    _8 <- tl_2;
    tl_2 <- any Creusot_Node_Type.t_node t;
    _0 <- ([#"/all/creusot.rs" 949 35 949 54] sll_append _7 _8);
    goto BB8
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve tl_2 };
    absurd
  }
  BB4 {
    assume { Resolve1.resolve _5 };
    _5 <- tl_2;
    tl_2 <- any Creusot_Node_Type.t_node t;
    goto BB5
  }
  BB5 {
    assume { Resolve1.resolve ( * self_1) };
    self_1 <- { self_1 with current = _5 };
    _5 <- any Creusot_Node_Type.t_node t;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB7
  }
  BB7 {
    goto BB9
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    return _0
  }
  
end
module Creusot_Impl19_SllCopy_Interface
  type t
  use prelude.Borrow
  use Creusot_Node_Type as Creusot_Node_Type
  val sll_copy [#"/all/creusot.rs" 954 4 954 44] (self : Creusot_Node_Type.t_node t) : Creusot_Node_Type.t_node t
    ensures { [#"/all/creusot.rs" 953 14 953 29] self = result }
    
end
module Creusot_Impl19_SllCopy
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_Node_Type.t_node t
  let rec cfg sll_copy [#"/all/creusot.rs" 954 4 954 44] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Node_Type.t_node t) : Creusot_Node_Type.t_node t
    ensures { [#"/all/creusot.rs" 953 14 953 29] self = result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Node_Type.t_node t;
  var self_1 : Creusot_Node_Type.t_node t;
  var _3 : isize;
  var elem_4 : t;
  var next_5 : Creusot_Node_Type.t_node t;
  var de_6 : t;
  var result_7 : Creusot_Node_Type.t_node t;
  var _8 : Creusot_Node_Type.t_node t;
  var next_9 : Creusot_Node_Type.t_node t;
  var _10 : Creusot_Node_Type.t_node t;
  var _11 : t;
  var _12 : Creusot_Node_Type.t_node t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    elem_4 <- Creusot_Node_Type.cons_elem self_1;
    next_5 <- Creusot_Node_Type.cons_next self_1;
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve de_6 };
    de_6 <- elem_4;
    assume { Resolve2.resolve elem_4 };
    _8 <- next_5;
    assume { Resolve3.resolve next_5 };
    result_7 <- ([#"/all/creusot.rs" 959 23 959 38] sll_copy _8);
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    _0 <- Creusot_Node_Type.C_Nil;
    goto BB9
  }
  BB4 {
    assume { Resolve4.resolve _10 };
    _10 <- result_7;
    result_7 <- any Creusot_Node_Type.t_node t;
    next_9 <- _10;
    goto BB5
  }
  BB5 {
    assume { Resolve1.resolve _11 };
    _11 <- de_6;
    assume { Resolve1.resolve de_6 };
    assume { Resolve5.resolve _12 };
    _12 <- next_9;
    next_9 <- any Creusot_Node_Type.t_node t;
    _0 <- Creusot_Node_Type.C_Cons _11 _12;
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module Creusot_Impl19_SllLen_Interface
  type t
  use prelude.UInt16
  use prelude.Int
  use prelude.Borrow
  use Creusot_Node_Type as Creusot_Node_Type
  clone Core_Num_Impl7_Max_Stub as Max0
  clone Creusot_Impl0_Len_Stub as Len0 with
    type t = t,
    axiom .
  val sll_len [#"/all/creusot.rs" 997 4 997 28] (self : Creusot_Node_Type.t_node t) : uint16
    requires {[#"/all/creusot.rs" 995 15 995 38] Len0.len self <= UInt16.to_int Max0.mAX'}
    ensures { [#"/all/creusot.rs" 996 14 996 35] UInt16.to_int result = Len0.len self }
    
end
module Creusot_Impl19_SllLen
  type t
  use prelude.Int
  use prelude.UInt16
  use prelude.Borrow
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_Node_Type.t_node t
  clone Core_Num_Impl7_Max as Max0
  clone Creusot_Impl0_Len as Len0 with
    type t = t,
    axiom .
  let rec cfg sll_len [#"/all/creusot.rs" 997 4 997 28] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Node_Type.t_node t) : uint16
    requires {[#"/all/creusot.rs" 995 15 995 38] Len0.len self <= UInt16.to_int Max0.mAX'}
    ensures { [#"/all/creusot.rs" 996 14 996 35] UInt16.to_int result = Len0.len self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint16;
  var self_1 : Creusot_Node_Type.t_node t;
  var _4 : isize;
  var next_5 : Creusot_Node_Type.t_node t;
  var result_6 : uint16;
  var _7 : Creusot_Node_Type.t_node t;
  var _8 : uint16;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    next_5 <- Creusot_Node_Type.cons_next self_1;
    assume { Resolve0.resolve self_1 };
    _7 <- next_5;
    assume { Resolve1.resolve next_5 };
    result_6 <- ([#"/all/creusot.rs" 1001 23 1001 37] sll_len _7);
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"/all/creusot.rs" 999 21 999 22] (0 : uint16));
    goto BB5
  }
  BB4 {
    _8 <- result_6;
    _0 <- ([#"/all/creusot.rs" 1002 10 1002 22] _8 + ([#"/all/creusot.rs" 1002 20 1002 21] (1 : uint16)));
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Creusot_Impl19_SllSingleton_Interface
  type t
  use Creusot_Node_Type as Creusot_Node_Type
  val sll_singleton [#"/all/creusot.rs" 1031 4 1031 37] (elem : t) : Creusot_Node_Type.t_node t
end
module Creusot_Impl19_SllSingleton
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Creusot_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = t
  let rec cfg sll_singleton [#"/all/creusot.rs" 1031 4 1031 37] [@cfg:stackify] [@cfg:subregion_analysis] (elem : t) : Creusot_Node_Type.t_node t
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Node_Type.t_node t;
  var elem_1 : t;
  var next_2 : Creusot_Node_Type.t_node t;
  var _3 : Creusot_Node_Type.t_node t;
  var _4 : t;
  var _5 : Creusot_Node_Type.t_node t;
  {
    elem_1 <- elem;
    goto BB0
  }
  BB0 {
    _3 <- Creusot_Node_Type.C_Nil;
    next_2 <- _3;
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _4 };
    _4 <- elem_1;
    elem_1 <- any t;
    assume { Resolve1.resolve _5 };
    _5 <- next_2;
    next_2 <- any Creusot_Node_Type.t_node t;
    _0 <- Creusot_Node_Type.C_Cons _4 _5;
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Creusot_Impl20_IsSorted_Stub
  use prelude.Int
  use prelude.UInt16
  use Creusot_Node_Type as Creusot_Node_Type
  function is_sorted [#"/all/creusot.rs" 1047 4 1047 30] (self : Creusot_Node_Type.t_node uint16) : bool
end
module Creusot_Impl20_IsSorted_Interface
  use prelude.Int
  use prelude.UInt16
  use Creusot_Node_Type as Creusot_Node_Type
  function is_sorted [#"/all/creusot.rs" 1047 4 1047 30] (self : Creusot_Node_Type.t_node uint16) : bool
end
module Creusot_Impl20_IsSorted
  use prelude.Int
  use prelude.UInt16
  use Creusot_Node_Type as Creusot_Node_Type
  function is_sorted [#"/all/creusot.rs" 1047 4 1047 30] (self : Creusot_Node_Type.t_node uint16) : bool
  val is_sorted [#"/all/creusot.rs" 1047 4 1047 30] (self : Creusot_Node_Type.t_node uint16) : bool
    ensures { result = is_sorted self }
    
  axiom def : forall self : Creusot_Node_Type.t_node uint16 . is_sorted self = ([#"/all/creusot.rs" 1048 8 1058 9] match (self) with
    | Creusot_Node_Type.C_Nil -> true
    | Creusot_Node_Type.C_Cons elem next -> match (next) with
      | Creusot_Node_Type.C_Nil -> true
      | Creusot_Node_Type.C_Cons e _ -> elem <= e /\ is_sorted next
      end
    end)
end
module Creusot_Impl20_IsSorted_Impl
  use prelude.Int
  use prelude.UInt16
  use Creusot_Node_Type as Creusot_Node_Type
  let rec ghost function is_sorted [#"/all/creusot.rs" 1047 4 1047 30] (self : Creusot_Node_Type.t_node uint16) : bool
    variant {[#"/all/creusot.rs" 1046 14 1046 18] self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/all/creusot.rs" 1048 8 1058 9] match (self) with
      | Creusot_Node_Type.C_Nil -> true
      | Creusot_Node_Type.C_Cons elem next -> match (next) with
        | Creusot_Node_Type.C_Nil -> true
        | Creusot_Node_Type.C_Cons e _ -> pure {elem <= e} && is_sorted next
        end
      end
end
module Creusot_Impl20_SrtlInsert_Interface
  use prelude.Int
  use prelude.UInt16
  use Creusot_Node_Type as Creusot_Node_Type
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = uint16
  clone Creusot_Impl4_Elems_Stub as Elems0 with
    type t = uint16,
    function Insert0.insert = Insert0.insert,
    axiom .
  clone Creusot_Impl20_IsSorted_Stub as IsSorted0 with
    axiom .
  val srtl_insert [#"/all/creusot.rs" 1065 4 1065 40] (self : Creusot_Node_Type.t_node uint16) (v : uint16) : Creusot_Node_Type.t_node uint16
    requires {[#"/all/creusot.rs" 1062 15 1062 31] IsSorted0.is_sorted self}
    ensures { [#"/all/creusot.rs" 1063 14 1063 32] IsSorted0.is_sorted result }
    ensures { [#"/all/creusot.rs" 1064 14 1064 54] Elems0.elems result = Insert0.insert (Elems0.elems self) v }
    
end
module Creusot_Impl20_InsertionSort_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = uint16
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl20_IsSorted_Stub as IsSorted0 with
    axiom .
  clone Creusot_Impl4_Elems_Stub as Elems0 with
    type t = uint16,
    function Insert0.insert = Insert0.insert,
    axiom .
  val insertion_sort [#"/all/creusot.rs" 1069 4 1069 36] (self : Creusot_Node_Type.t_node uint16) : Creusot_Node_Type.t_node uint16
    ensures { [#"/all/creusot.rs" 1067 14 1067 44] Elems0.elems result = Elems0.elems self }
    ensures { [#"/all/creusot.rs" 1068 14 1068 32] IsSorted0.is_sorted result }
    
end
module Creusot_Impl20_InsertionSort
  use prelude.Int
  use prelude.UInt16
  use prelude.Borrow
  use prelude.IntSize
  clone CreusotContracts_Logic_Set_Impl0_Insert as Insert0 with
    type t = uint16
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl4_Elems as Elems0 with
    type t = uint16,
    function Insert0.insert = Insert0.insert,
    axiom .
  clone Creusot_Impl20_IsSorted as IsSorted0 with
    axiom .
  clone Creusot_Impl20_SrtlInsert_Interface as SrtlInsert0 with
    function IsSorted0.is_sorted = IsSorted0.is_sorted,
    function Elems0.elems = Elems0.elems,
    function Insert0.insert = Insert0.insert
  let rec cfg insertion_sort [#"/all/creusot.rs" 1069 4 1069 36] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Node_Type.t_node uint16) : Creusot_Node_Type.t_node uint16
    ensures { [#"/all/creusot.rs" 1067 14 1067 44] Elems0.elems result = Elems0.elems self }
    ensures { [#"/all/creusot.rs" 1068 14 1068 32] IsSorted0.is_sorted result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Node_Type.t_node uint16;
  var self_1 : Creusot_Node_Type.t_node uint16;
  var _4 : isize;
  var elem_5 : uint16;
  var next_6 : Creusot_Node_Type.t_node uint16;
  var de_7 : uint16;
  var result_8 : Creusot_Node_Type.t_node uint16;
  var _9 : Creusot_Node_Type.t_node uint16;
  var _10 : Creusot_Node_Type.t_node uint16;
  var _11 : uint16;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    elem_5 <- Creusot_Node_Type.cons_elem self_1;
    next_6 <- Creusot_Node_Type.cons_next self_1;
    de_7 <- elem_5;
    _9 <- next_6;
    result_8 <- ([#"/all/creusot.rs" 1074 23 1074 44] insertion_sort _9);
    goto BB4
  }
  BB2 {
    absurd
  }
  BB3 {
    _0 <- Creusot_Node_Type.C_Nil;
    goto BB7
  }
  BB4 {
    _10 <- result_8;
    result_8 <- any Creusot_Node_Type.t_node uint16;
    _11 <- de_7;
    _0 <- ([#"/all/creusot.rs" 1075 10 1075 32] SrtlInsert0.srtl_insert _10 _11);
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Creusot_Impl21_TreeCopy_Interface
  type t
  use prelude.Borrow
  use Creusot_Tree_Type as Creusot_Tree_Type
  clone Creusot_Impl7_Elems_Stub as Elems0 with
    type t = t,
    axiom .
  val tree_copy [#"/all/creusot.rs" 1111 4 1111 45] (self : Creusot_Tree_Type.t_tree t) : Creusot_Tree_Type.t_tree t
    ensures { [#"/all/creusot.rs" 1110 14 1110 44] Elems0.elems result = Elems0.elems self }
    
end
module Creusot_Impl21_TreeCopy
  type t
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Tree_Type as Creusot_Tree_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Logic_Set_Impl0_Insert as Insert0 with
    type t = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = Creusot_Tree_Type.t_tree t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Creusot_Tree_Type.t_tree t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Creusot_Tree_Type.t_tree t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_Tree_Type.t_tree t
  clone Creusot_Impl7_Elems as Elems0 with
    type t = t,
    function Insert0.insert = Insert0.insert,
    axiom .
  let rec cfg tree_copy [#"/all/creusot.rs" 1111 4 1111 45] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Tree_Type.t_tree t) : Creusot_Tree_Type.t_tree t
    ensures { [#"/all/creusot.rs" 1110 14 1110 44] Elems0.elems result = Elems0.elems self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Tree_Type.t_tree t;
  var self_1 : Creusot_Tree_Type.t_tree t;
  var _3 : isize;
  var f_4 : t;
  var left_5 : Creusot_Tree_Type.t_tree t;
  var right_6 : Creusot_Tree_Type.t_tree t;
  var de_7 : t;
  var result_1_8 : Creusot_Tree_Type.t_tree t;
  var _9 : Creusot_Tree_Type.t_tree t;
  var result_2_10 : Creusot_Tree_Type.t_tree t;
  var _11 : Creusot_Tree_Type.t_tree t;
  var right_12 : Creusot_Tree_Type.t_tree t;
  var _13 : Creusot_Tree_Type.t_tree t;
  var left_14 : Creusot_Tree_Type.t_tree t;
  var _15 : Creusot_Tree_Type.t_tree t;
  var _16 : t;
  var _17 : Creusot_Tree_Type.t_tree t;
  var _18 : Creusot_Tree_Type.t_tree t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Creusot_Tree_Type.C_Leaf -> goto BB3
      | Creusot_Tree_Type.C_Node _ _ _ -> goto BB1
      end
  }
  BB1 {
    f_4 <- Creusot_Tree_Type.node_f self_1;
    left_5 <- Creusot_Tree_Type.node_left self_1;
    right_6 <- Creusot_Tree_Type.node_right self_1;
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve de_7 };
    de_7 <- f_4;
    assume { Resolve2.resolve f_4 };
    _9 <- left_5;
    assume { Resolve3.resolve left_5 };
    result_1_8 <- ([#"/all/creusot.rs" 1116 25 1116 41] tree_copy _9);
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    _0 <- Creusot_Tree_Type.C_Leaf;
    goto BB14
  }
  BB4 {
    _11 <- right_6;
    assume { Resolve3.resolve right_6 };
    result_2_10 <- ([#"/all/creusot.rs" 1117 25 1117 42] tree_copy _11);
    goto BB5
  }
  BB5 {
    assume { Resolve4.resolve _13 };
    _13 <- result_2_10;
    result_2_10 <- any Creusot_Tree_Type.t_tree t;
    right_12 <- _13;
    goto BB6
  }
  BB6 {
    assume { Resolve4.resolve _15 };
    _15 <- result_1_8;
    result_1_8 <- any Creusot_Tree_Type.t_tree t;
    left_14 <- _15;
    goto BB7
  }
  BB7 {
    assume { Resolve1.resolve _16 };
    _16 <- de_7;
    assume { Resolve1.resolve de_7 };
    assume { Resolve5.resolve _17 };
    _17 <- left_14;
    left_14 <- any Creusot_Tree_Type.t_tree t;
    assume { Resolve5.resolve _18 };
    _18 <- right_12;
    right_12 <- any Creusot_Tree_Type.t_tree t;
    _0 <- Creusot_Tree_Type.C_Node _16 _17 _18;
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    goto BB14
  }
  BB14 {
    return _0
  }
  
end
module Creusot_Impl21_TreeSize_Interface
  type t
  use prelude.UInt16
  use prelude.Int
  use prelude.Borrow
  use Creusot_Tree_Type as Creusot_Tree_Type
  clone Core_Num_Impl7_Max_Stub as Max0
  clone Creusot_Impl7_Size_Stub as Size0 with
    type t = t,
    axiom .
  val tree_size [#"/all/creusot.rs" 1209 4 1209 30] (self : Creusot_Tree_Type.t_tree t) : uint16
    requires {[#"/all/creusot.rs" 1207 15 1207 39] Size0.size self <= UInt16.to_int Max0.mAX'}
    ensures { [#"/all/creusot.rs" 1208 14 1208 36] UInt16.to_int result = Size0.size self }
    
end
module Creusot_Impl21_TreeSize
  type t
  use prelude.Int
  use prelude.UInt16
  use prelude.Borrow
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Tree_Type as Creusot_Tree_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Creusot_Tree_Type.t_tree t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_Tree_Type.t_tree t
  clone Core_Num_Impl7_Max as Max0
  clone Creusot_Impl7_Size as Size0 with
    type t = t,
    axiom .
  let rec cfg tree_size [#"/all/creusot.rs" 1209 4 1209 30] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Tree_Type.t_tree t) : uint16
    requires {[#"/all/creusot.rs" 1207 15 1207 39] Size0.size self <= UInt16.to_int Max0.mAX'}
    ensures { [#"/all/creusot.rs" 1208 14 1208 36] UInt16.to_int result = Size0.size self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint16;
  var self_1 : Creusot_Tree_Type.t_tree t;
  var _4 : isize;
  var left_5 : Creusot_Tree_Type.t_tree t;
  var right_6 : Creusot_Tree_Type.t_tree t;
  var result_1_7 : uint16;
  var _8 : Creusot_Tree_Type.t_tree t;
  var result_2_9 : uint16;
  var _10 : Creusot_Tree_Type.t_tree t;
  var _11 : uint16;
  var _12 : uint16;
  var _13 : uint16;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Creusot_Tree_Type.C_Leaf -> goto BB3
      | Creusot_Tree_Type.C_Node _ _ _ -> goto BB1
      end
  }
  BB1 {
    left_5 <- Creusot_Tree_Type.node_left self_1;
    right_6 <- Creusot_Tree_Type.node_right self_1;
    assume { Resolve0.resolve self_1 };
    _8 <- left_5;
    assume { Resolve1.resolve left_5 };
    result_1_7 <- ([#"/all/creusot.rs" 1213 25 1213 41] tree_size _8);
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"/all/creusot.rs" 1211 22 1211 23] (0 : uint16));
    goto BB6
  }
  BB4 {
    _10 <- right_6;
    assume { Resolve1.resolve right_6 };
    result_2_9 <- ([#"/all/creusot.rs" 1214 25 1214 42] tree_size _10);
    goto BB5
  }
  BB5 {
    _12 <- result_1_7;
    _13 <- result_2_9;
    _11 <- ([#"/all/creusot.rs" 1215 11 1215 30] _12 + _13);
    _0 <- ([#"/all/creusot.rs" 1215 10 1215 35] _11 + ([#"/all/creusot.rs" 1215 33 1215 34] (1 : uint16)));
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Creusot_ListRt_Type
  type t_listrt 't =
    | C_Nil
    | C_Cons ('t, t_listrt 't)
    
end
module Creusot_Impl22_Elems_Stub
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  function elems [#"/all/creusot.rs" 1235 4 1235 35] (self : Creusot_ListRt_Type.t_listrt t) : Set.set t
end
module Creusot_Impl22_Elems_Interface
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  function elems [#"/all/creusot.rs" 1235 4 1235 35] (self : Creusot_ListRt_Type.t_listrt t) : Set.set t
  axiom elems_spec : forall self : Creusot_ListRt_Type.t_listrt t . [#"/all/creusot.rs" 1231 14 1234 6] elems self = match (self) with
    | Creusot_ListRt_Type.C_Nil -> Set.empty 
    | Creusot_ListRt_Type.C_Cons (hd, tl) -> Insert0.insert (elems tl) hd
    end
end
module Creusot_Impl22_Elems
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  function elems [#"/all/creusot.rs" 1235 4 1235 35] (self : Creusot_ListRt_Type.t_listrt t) : Set.set t
  val elems [#"/all/creusot.rs" 1235 4 1235 35] (self : Creusot_ListRt_Type.t_listrt t) : Set.set t
    ensures { result = elems self }
    
  axiom elems_spec : forall self : Creusot_ListRt_Type.t_listrt t . [#"/all/creusot.rs" 1231 14 1234 6] elems self = match (self) with
    | Creusot_ListRt_Type.C_Nil -> Set.empty 
    | Creusot_ListRt_Type.C_Cons (hd, tl) -> Insert0.insert (elems tl) hd
    end
end
module Creusot_Impl22_Len_Stub
  type t
  use prelude.Int
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  function len [#"/all/creusot.rs" 1248 4 1248 30] (self : Creusot_ListRt_Type.t_listrt t) : int
end
module Creusot_Impl22_Len_Interface
  type t
  use prelude.Int
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  function len [#"/all/creusot.rs" 1248 4 1248 30] (self : Creusot_ListRt_Type.t_listrt t) : int
  axiom len_spec : forall self : Creusot_ListRt_Type.t_listrt t . [#"/all/creusot.rs" 1243 14 1246 6] len self = match (self) with
    | Creusot_ListRt_Type.C_Nil -> 0
    | Creusot_ListRt_Type.C_Cons (_, tl) -> 1 + len tl
    end
end
module Creusot_Impl22_Len
  type t
  use prelude.Int
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  function len [#"/all/creusot.rs" 1248 4 1248 30] (self : Creusot_ListRt_Type.t_listrt t) : int
  val len [#"/all/creusot.rs" 1248 4 1248 30] (self : Creusot_ListRt_Type.t_listrt t) : int
    ensures { result = len self }
    
  axiom len_spec : forall self : Creusot_ListRt_Type.t_listrt t . [#"/all/creusot.rs" 1243 14 1246 6] len self = match (self) with
    | Creusot_ListRt_Type.C_Nil -> 0
    | Creusot_ListRt_Type.C_Cons (_, tl) -> 1 + len tl
    end
end
module Creusot_Impl24_ElemsList_Stub
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  clone Creusot_Impl22_Elems_Stub as Elems0 with
    type t = t,
    function Insert0.insert = Insert0.insert,
    axiom .
  function elems_list [#"/all/creusot.rs" 1347 4 1347 40] (self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t)) : Set.set t
    
end
module Creusot_Impl24_ElemsList_Interface
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  clone Creusot_Impl22_Elems_Stub as Elems0 with
    type t = t,
    function Insert0.insert = Insert0.insert,
    axiom .
  function elems_list [#"/all/creusot.rs" 1347 4 1347 40] (self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t)) : Set.set t
    
  axiom elems_list_spec : forall self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t) . [#"/all/creusot.rs" 1343 14 1346 6] elems_list self = match (self) with
    | Creusot_ListRt_Type.C_Nil -> Set.empty 
    | Creusot_ListRt_Type.C_Cons (hd, tl) -> Set.union (Elems0.elems hd) (elems_list tl)
    end
end
module Creusot_Impl24_ElemsList
  type t
  use set.Set
  clone CreusotContracts_Logic_Set_Impl0_Insert_Stub as Insert0 with
    type t = t
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  clone Creusot_Impl22_Elems_Stub as Elems0 with
    type t = t,
    function Insert0.insert = Insert0.insert,
    axiom .
  function elems_list [#"/all/creusot.rs" 1347 4 1347 40] (self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t)) : Set.set t
    
  val elems_list [#"/all/creusot.rs" 1347 4 1347 40] (self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t)) : Set.set t
    ensures { result = elems_list self }
    
  axiom elems_list_spec : forall self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t) . [#"/all/creusot.rs" 1343 14 1346 6] elems_list self = match (self) with
    | Creusot_ListRt_Type.C_Nil -> Set.empty 
    | Creusot_ListRt_Type.C_Cons (hd, tl) -> Set.union (Elems0.elems hd) (elems_list tl)
    end
end
module Creusot_Impl24_Mlen_Stub
  type t
  use prelude.Int
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  clone Creusot_Impl22_Len_Stub as Len0 with
    type t = t,
    axiom .
  function mlen [#"/all/creusot.rs" 1359 4 1359 31] (self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t)) : int
    
end
module Creusot_Impl24_Mlen_Interface
  type t
  use prelude.Int
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  clone Creusot_Impl22_Len_Stub as Len0 with
    type t = t,
    axiom .
  function mlen [#"/all/creusot.rs" 1359 4 1359 31] (self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t)) : int
    
  axiom mlen_spec : forall self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t) . [#"/all/creusot.rs" 1355 14 1358 6] mlen self = match (self) with
    | Creusot_ListRt_Type.C_Nil -> 0
    | Creusot_ListRt_Type.C_Cons (hd, tl) -> Len0.len hd + mlen tl
    end
end
module Creusot_Impl24_Mlen
  type t
  use prelude.Int
  use Creusot_ListRt_Type as Creusot_ListRt_Type
  clone Creusot_Impl22_Len_Stub as Len0 with
    type t = t,
    axiom .
  function mlen [#"/all/creusot.rs" 1359 4 1359 31] (self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t)) : int
    
  val mlen [#"/all/creusot.rs" 1359 4 1359 31] (self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t)) : int
    ensures { result = mlen self }
    
  axiom mlen_spec : forall self : Creusot_ListRt_Type.t_listrt (Creusot_ListRt_Type.t_listrt t) . [#"/all/creusot.rs" 1355 14 1358 6] mlen self = match (self) with
    | Creusot_ListRt_Type.C_Nil -> 0
    | Creusot_ListRt_Type.C_Cons (hd, tl) -> Len0.len hd + mlen tl
    end
end
module Creusot_Impl25_Sum_Stub
  use prelude.Int
  use prelude.UInt16
  use Creusot_Node_Type as Creusot_Node_Type
  function sum [#"/all/creusot.rs" 1404 4 1404 30] (self : Creusot_Node_Type.t_node uint16) : int
end
module Creusot_Impl25_Sum_Interface
  use prelude.Int
  use prelude.UInt16
  use Creusot_Node_Type as Creusot_Node_Type
  function sum [#"/all/creusot.rs" 1404 4 1404 30] (self : Creusot_Node_Type.t_node uint16) : int
  axiom sum_spec : forall self : Creusot_Node_Type.t_node uint16 . [#"/all/creusot.rs" 1400 14 1403 6] sum self = match (self) with
    | Creusot_Node_Type.C_Cons elem next -> UInt16.to_int elem + sum next
    | Creusot_Node_Type.C_Nil -> 0
    end
end
module Creusot_Impl25_Sum
  use prelude.Int
  use prelude.UInt16
  use Creusot_Node_Type as Creusot_Node_Type
  function sum [#"/all/creusot.rs" 1404 4 1404 30] (self : Creusot_Node_Type.t_node uint16) : int
  val sum [#"/all/creusot.rs" 1404 4 1404 30] (self : Creusot_Node_Type.t_node uint16) : int
    ensures { result = sum self }
    
  axiom sum_spec : forall self : Creusot_Node_Type.t_node uint16 . [#"/all/creusot.rs" 1400 14 1403 6] sum self = match (self) with
    | Creusot_Node_Type.C_Cons elem next -> UInt16.to_int elem + sum next
    | Creusot_Node_Type.C_Nil -> 0
    end
end
module Creusot_Impl25_SumX_Interface
  use prelude.UInt16
  use prelude.Int
  use prelude.Borrow
  use Creusot_Node_Type as Creusot_Node_Type
  clone Core_Num_Impl7_Max_Stub as Max0
  clone Creusot_Impl25_Sum_Stub as Sum0 with
    axiom .
  val sum_x [#"/all/creusot.rs" 1413 4 1413 26] (self : Creusot_Node_Type.t_node uint16) : uint16
    requires {[#"/all/creusot.rs" 1411 15 1411 38] Sum0.sum self <= UInt16.to_int Max0.mAX'}
    ensures { [#"/all/creusot.rs" 1412 14 1412 35] UInt16.to_int result = Sum0.sum self }
    
end
module Creusot_Impl25_SumX
  use prelude.Int
  use prelude.UInt16
  use prelude.Borrow
  use prelude.IntSize
  clone Core_Num_Impl7_Max as Max0
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl25_Sum as Sum0 with
    axiom .
  let rec cfg sum_x [#"/all/creusot.rs" 1413 4 1413 26] [@cfg:stackify] [@cfg:subregion_analysis] (self : Creusot_Node_Type.t_node uint16) : uint16
    requires {[#"/all/creusot.rs" 1411 15 1411 38] Sum0.sum self <= UInt16.to_int Max0.mAX'}
    ensures { [#"/all/creusot.rs" 1412 14 1412 35] UInt16.to_int result = Sum0.sum self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint16;
  var self_1 : Creusot_Node_Type.t_node uint16;
  var _4 : isize;
  var elem_5 : uint16;
  var next_6 : Creusot_Node_Type.t_node uint16;
  var de_7 : uint16;
  var result_8 : uint16;
  var _9 : Creusot_Node_Type.t_node uint16;
  var _10 : uint16;
  var _11 : uint16;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    elem_5 <- Creusot_Node_Type.cons_elem self_1;
    next_6 <- Creusot_Node_Type.cons_next self_1;
    de_7 <- elem_5;
    _9 <- next_6;
    result_8 <- ([#"/all/creusot.rs" 1418 23 1418 35] sum_x _9);
    goto BB4
  }
  BB2 {
    absurd
  }
  BB3 {
    _0 <- ([#"/all/creusot.rs" 1415 21 1415 22] (0 : uint16));
    goto BB5
  }
  BB4 {
    _10 <- de_7;
    _11 <- result_8;
    _0 <- ([#"/all/creusot.rs" 1419 10 1419 23] _10 + _11);
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Creusot_Impl25_TakeSomeRest_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  use Creusot_Node_Type as Creusot_Node_Type
  clone Creusot_Impl25_Sum_Stub as Sum0 with
    axiom .
  val take_some_rest [#"/all/creusot.rs" 1427 4 1427 62] (self : borrowed (Creusot_Node_Type.t_node uint16)) : (borrowed uint16, borrowed (Creusot_Node_Type.t_node uint16))
    requires {[#"/all/creusot.rs" 1424 15 1424 29] Sum0.sum ( * self) > 0}
    ensures { [#"/all/creusot.rs" 1425 14 1426 71] Sum0.sum ( ^ self) - Sum0.sum ( * self) = UInt16.to_int ( ^ (let (a, _) = result in a)) + Sum0.sum ( ^ (let (_, a) = result in a)) - UInt16.to_int ( * (let (a, _) = result in a)) - Sum0.sum ( * (let (_, a) = result in a)) }
    
end
module Creusot_Impl25_TakeSomeRest
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  use prelude.IntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Creusot_Node_Type as Creusot_Node_Type
  use Alloc_Boxed_Box_Type as Alloc_Boxed_Box_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Creusot_Node_Type.t_node uint16
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = uint16
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Node_Type.t_node uint16
  clone Creusot_Impl25_Sum as Sum0 with
    axiom .
  let rec cfg take_some_rest [#"/all/creusot.rs" 1427 4 1427 62] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Node_Type.t_node uint16)) : (borrowed uint16, borrowed (Creusot_Node_Type.t_node uint16))
    requires {[#"/all/creusot.rs" 1424 15 1424 29] Sum0.sum ( * self) > 0}
    ensures { [#"/all/creusot.rs" 1425 14 1426 71] Sum0.sum ( ^ self) - Sum0.sum ( * self) = UInt16.to_int ( ^ (let (a, _) = result in a)) + Sum0.sum ( ^ (let (_, a) = result in a)) - UInt16.to_int ( * (let (a, _) = result in a)) - Sum0.sum ( * (let (_, a) = result in a)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : (borrowed uint16, borrowed (Creusot_Node_Type.t_node uint16));
  var self_1 : borrowed (Creusot_Node_Type.t_node uint16);
  var _4 : isize;
  var _5 : ();
  var elem_6 : borrowed uint16;
  var next_7 : borrowed (Creusot_Node_Type.t_node uint16);
  var _8 : borrowed uint16;
  var _9 : borrowed (Creusot_Node_Type.t_node uint16);
  var _10 : borrowed (Creusot_Node_Type.t_node uint16);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch ( * self_1)
      | Creusot_Node_Type.C_Nil -> goto BB3
      | Creusot_Node_Type.C_Cons _ _ -> goto BB1
      end
  }
  BB1 {
    elem_6 <- borrow_mut (Creusot_Node_Type.cons_elem ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Node_Type.C_Cons a b =  * self_1 in Creusot_Node_Type.C_Cons ( ^ elem_6) b) };
    next_7 <- borrow_mut (Creusot_Node_Type.cons_next ( * self_1));
    self_1 <- { self_1 with current = (let Creusot_Node_Type.C_Cons a b =  * self_1 in Creusot_Node_Type.C_Cons a ( ^ next_7)) };
    assume { Resolve0.resolve self_1 };
    _8 <- borrow_mut ( * elem_6);
    elem_6 <- { elem_6 with current = ( ^ _8) };
    assume { Resolve1.resolve elem_6 };
    _10 <- borrow_mut ( * next_7);
    next_7 <- { next_7 with current = ( ^ _10) };
    assume { Resolve2.resolve next_7 };
    _9 <- borrow_mut ( * _10);
    _10 <- { _10 with current = ( ^ _9) };
    assume { Resolve0.resolve _10 };
    _0 <- (_8, _9);
    return _0
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  
end
module Creusot_Swap_Interface
  type t
  val swap [#"/all/creusot.rs" 1436 0 1436 31] (x : (t, t)) : (t, t)
    ensures { [#"/all/creusot.rs" 1435 10 1435 44] (let (a, _) = result in a) = (let (_, a) = x in a) /\ (let (_, a) = result in a) = (let (a, _) = x in a) }
    
end
module Creusot_Swap
  type t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = t
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve1 with
    type t1 = t,
    type t2 = t,
    predicate Resolve0.resolve = Resolve0.resolve,
    predicate Resolve1.resolve = Resolve0.resolve
  let rec cfg swap [#"/all/creusot.rs" 1436 0 1436 31] [@cfg:stackify] [@cfg:subregion_analysis] (x : (t, t)) : (t, t)
    ensures { [#"/all/creusot.rs" 1435 10 1435 44] (let (a, _) = result in a) = (let (_, a) = x in a) /\ (let (_, a) = result in a) = (let (a, _) = x in a) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : (t, t);
  var x_1 : (t, t);
  var _3 : t;
  var _4 : t;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _3 };
    _3 <- (let (_, a) = x_1 in a);
    x_1 <- (let (a, b) = x_1 in (a, any t));
    assume { Resolve0.resolve _4 };
    _4 <- (let (a, _) = x_1 in a);
    x_1 <- (let (a, b) = x_1 in (any t, b));
    assume { Resolve1.resolve x_1 };
    _0 <- (_3, _4);
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Creusot_TakeMax_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  val take_max [#"/all/creusot.rs" 1442 0 1442 64] (ma : borrowed uint16) (mb : borrowed uint16) : borrowed uint16
    ensures { [#"/all/creusot.rs" 1440 0 1441 57] if  * ma >=  * mb then
       * mb =  ^ mb /\ result = ma
    else
       * ma =  ^ ma /\ result = mb
     }
    
end
module Creusot_TakeMax
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = uint16
  let rec cfg take_max [#"/all/creusot.rs" 1442 0 1442 64] [@cfg:stackify] [@cfg:subregion_analysis] (ma : borrowed uint16) (mb : borrowed uint16) : borrowed uint16
    ensures { [#"/all/creusot.rs" 1440 0 1441 57] if  * ma >=  * mb then
       * mb =  ^ mb /\ result = ma
    else
       * ma =  ^ ma /\ result = mb
     }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed uint16;
  var ma_1 : borrowed uint16;
  var mb_2 : borrowed uint16;
  var _3 : borrowed uint16;
  var de_mb_5 : uint16;
  var de_ma_6 : uint16;
  var _7 : borrowed uint16;
  var _8 : bool;
  var _9 : uint16;
  var _10 : uint16;
  var _11 : borrowed uint16;
  {
    ma_1 <- ma;
    mb_2 <- mb;
    goto BB0
  }
  BB0 {
    de_mb_5 <-  * mb_2;
    de_ma_6 <-  * ma_1;
    _9 <- de_mb_5;
    _10 <- de_ma_6;
    _8 <- ([#"/all/creusot.rs" 1445 5 1445 19] _9 <= _10);
    switch (_8)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    assume { Resolve0.resolve mb_2 };
    _11 <- borrow_mut ( * ma_1);
    ma_1 <- { ma_1 with current = ( ^ _11) };
    assume { Resolve0.resolve ma_1 };
    _7 <- borrow_mut ( * _11);
    _11 <- { _11 with current = ( ^ _7) };
    assume { Resolve0.resolve _11 };
    goto BB3
  }
  BB2 {
    assume { Resolve0.resolve ma_1 };
    _7 <- borrow_mut ( * mb_2);
    mb_2 <- { mb_2 with current = ( ^ _7) };
    assume { Resolve0.resolve mb_2 };
    goto BB3
  }
  BB3 {
    _3 <- borrow_mut ( * _7);
    _7 <- { _7 with current = ( ^ _3) };
    assume { Resolve0.resolve _7 };
    _0 <- borrow_mut ( * _3);
    _3 <- { _3 with current = ( ^ _0) };
    assume { Resolve0.resolve _3 };
    return _0
  }
  
end
module Creusot_Unnest_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  val unnest [#"/all/creusot.rs" 1451 0 1451 64] (x : borrowed (borrowed int32)) : borrowed int32
    ensures { [#"/all/creusot.rs" 1448 10 1448 24]  * result =  *  * x }
    ensures { [#"/all/creusot.rs" 1449 10 1449 24]  ^ result =  *  ^ x }
    ensures { [#"/all/creusot.rs" 1450 10 1450 20]  ^  * x =  ^  ^ x }
    
end
module Creusot_Unnest
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = borrowed int32
  let rec cfg unnest [#"/all/creusot.rs" 1451 0 1451 64] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (borrowed int32)) : borrowed int32
    ensures { [#"/all/creusot.rs" 1448 10 1448 24]  * result =  *  * x }
    ensures { [#"/all/creusot.rs" 1449 10 1449 24]  ^ result =  *  ^ x }
    ensures { [#"/all/creusot.rs" 1450 10 1450 20]  ^  * x =  ^  ^ x }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed int32;
  var x_1 : borrowed (borrowed int32);
  var _2 : borrowed int32;
  var _6 : borrowed int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _6 <- borrow_mut ( *  * x_1);
    x_1 <- { x_1 with current = { ( * x_1) with current = ( ^ _6) } };
    assume { Resolve0.resolve x_1 };
    _2 <- borrow_mut ( * _6);
    _6 <- { _6 with current = ( ^ _2) };
    assume { Resolve1.resolve _6 };
    _0 <- borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Resolve1.resolve _2 };
    return _0
  }
  
end
module Creusot_WrappingAdd_Interface
  use prelude.Int
  use prelude.UInt16
  val wrapping_add [#"/all/creusot.rs" 1457 0 1457 42] (a : uint16) (b : uint16) : uint16
    ensures { [#"/all/creusot.rs" 1456 10 1456 74] result = (if a + b >= (256 : uint16) then
      a + b - (256 : uint16)
    else
      a + b
    ) }
    
end
module Creusot_TestU8WrappingAdd_Interface
  use prelude.Int
  use prelude.UInt16
  val test_u8_wrapping_add [#"/all/creusot.rs" 1461 0 1461 50] (a : uint16) (b : uint16) : uint16
    ensures { [#"/all/creusot.rs" 1460 10 1460 54] result = a + b \/ result = a + b - (256 : uint16) }
    
end
module Creusot_TestU8WrappingAdd
  use prelude.Int
  use prelude.UInt16
  clone Creusot_WrappingAdd_Interface as WrappingAdd0
  let rec cfg test_u8_wrapping_add [#"/all/creusot.rs" 1461 0 1461 50] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint16) (b : uint16) : uint16
    ensures { [#"/all/creusot.rs" 1460 10 1460 54] result = a + b \/ result = a + b - (256 : uint16) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint16;
  var a_1 : uint16;
  var b_2 : uint16;
  var result_4 : uint16;
  var _5 : uint16;
  var _6 : uint16;
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _5 <- b_2;
    _6 <- a_1;
    result_4 <- ([#"/all/creusot.rs" 1462 15 1462 40] WrappingAdd0.wrapping_add _5 _6);
    goto BB1
  }
  BB1 {
    _0 <- result_4;
    return _0
  }
  
end
module Creusot_Account_Type
  use prelude.Int
  use prelude.UInt16
  type t_account  =
    | C_Account uint16
    
  let function account_bal (self : t_account) : uint16 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Account a -> a
      end
end
module Creusot_Impl26_Balance_Stub
  use prelude.Int
  use prelude.UInt16
  use Creusot_Account_Type as Creusot_Account_Type
  function balance [#"/all/creusot.rs" 1473 4 1473 27] (self : Creusot_Account_Type.t_account) : uint16
end
module Creusot_Impl26_Balance_Interface
  use prelude.Int
  use prelude.UInt16
  use Creusot_Account_Type as Creusot_Account_Type
  function balance [#"/all/creusot.rs" 1473 4 1473 27] (self : Creusot_Account_Type.t_account) : uint16
end
module Creusot_Impl26_Balance
  use prelude.Int
  use prelude.UInt16
  use Creusot_Account_Type as Creusot_Account_Type
  function balance [#"/all/creusot.rs" 1473 4 1473 27] (self : Creusot_Account_Type.t_account) : uint16 =
    [#"/all/creusot.rs" 1474 8 1474 16] Creusot_Account_Type.account_bal self
  val balance [#"/all/creusot.rs" 1473 4 1473 27] (self : Creusot_Account_Type.t_account) : uint16
    ensures { result = balance self }
    
end
module Creusot_Impl26_Deposit_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  use Creusot_Account_Type as Creusot_Account_Type
  clone Core_Num_Impl7_Max_Stub as Max0
  clone Creusot_Impl26_Balance_Stub as Balance0
  val deposit [#"/all/creusot.rs" 1479 4 1479 38] (self : borrowed (Creusot_Account_Type.t_account)) (amount : uint16) : ()
    requires {[#"/all/creusot.rs" 1477 15 1477 50] Balance0.balance ( * self) + amount <= Max0.mAX'}
    ensures { [#"/all/creusot.rs" 1478 14 1478 58] Balance0.balance ( ^ self) = Balance0.balance ( * self) + amount }
    
end
module Creusot_Impl26_Deposit
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  use Creusot_Account_Type as Creusot_Account_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Account_Type.t_account
  clone Core_Num_Impl7_Max as Max0
  clone Creusot_Impl26_Balance as Balance0
  let rec cfg deposit [#"/all/creusot.rs" 1479 4 1479 38] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Account_Type.t_account)) (amount : uint16) : ()
    requires {[#"/all/creusot.rs" 1477 15 1477 50] Balance0.balance ( * self) + amount <= Max0.mAX'}
    ensures { [#"/all/creusot.rs" 1478 14 1478 58] Balance0.balance ( ^ self) = Balance0.balance ( * self) + amount }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_Account_Type.t_account);
  var amount_2 : uint16;
  var de_5 : uint16;
  var new_6 : Creusot_Account_Type.t_account;
  var _7 : uint16;
  var _8 : uint16;
  var _9 : uint16;
  var _10 : Creusot_Account_Type.t_account;
  {
    self_1 <- self;
    amount_2 <- amount;
    goto BB0
  }
  BB0 {
    de_5 <- Creusot_Account_Type.account_bal ( * self_1);
    _8 <- de_5;
    _9 <- amount_2;
    _7 <- ([#"/all/creusot.rs" 1481 31 1481 44] _8 + _9);
    new_6 <- Creusot_Account_Type.C_Account _7;
    _10 <- new_6;
    new_6 <- any Creusot_Account_Type.t_account;
    self_1 <- { self_1 with current = _10 };
    _10 <- any Creusot_Account_Type.t_account;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_Impl26_Withdraw_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  use Creusot_Account_Type as Creusot_Account_Type
  clone Creusot_Impl26_Balance_Stub as Balance0
  val withdraw [#"/all/creusot.rs" 1487 4 1487 39] (self : borrowed (Creusot_Account_Type.t_account)) (amount : uint16) : ()
    requires {[#"/all/creusot.rs" 1485 15 1485 39] amount <= Balance0.balance ( * self)}
    ensures { [#"/all/creusot.rs" 1486 14 1486 58] Balance0.balance ( ^ self) = Balance0.balance ( * self) - amount }
    
end
module Creusot_Impl26_Withdraw
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  use Creusot_Account_Type as Creusot_Account_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Account_Type.t_account
  clone Creusot_Impl26_Balance as Balance0
  let rec cfg withdraw [#"/all/creusot.rs" 1487 4 1487 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Account_Type.t_account)) (amount : uint16) : ()
    requires {[#"/all/creusot.rs" 1485 15 1485 39] amount <= Balance0.balance ( * self)}
    ensures { [#"/all/creusot.rs" 1486 14 1486 58] Balance0.balance ( ^ self) = Balance0.balance ( * self) - amount }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_Account_Type.t_account);
  var amount_2 : uint16;
  var de_5 : uint16;
  var new_6 : Creusot_Account_Type.t_account;
  var _7 : uint16;
  var _8 : uint16;
  var _9 : uint16;
  var _10 : Creusot_Account_Type.t_account;
  {
    self_1 <- self;
    amount_2 <- amount;
    goto BB0
  }
  BB0 {
    de_5 <- Creusot_Account_Type.account_bal ( * self_1);
    _8 <- de_5;
    _9 <- amount_2;
    _7 <- ([#"/all/creusot.rs" 1489 31 1489 44] _8 - _9);
    new_6 <- Creusot_Account_Type.C_Account _7;
    _10 <- new_6;
    new_6 <- any Creusot_Account_Type.t_account;
    self_1 <- { self_1 with current = _10 };
    _10 <- any Creusot_Account_Type.t_account;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_Impl26_Transfer_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  use Creusot_Account_Type as Creusot_Account_Type
  clone Core_Num_Impl7_Max_Stub as Max0
  clone Creusot_Impl26_Balance_Stub as Balance0
  val transfer [#"/all/creusot.rs" 1497 4 1497 60] (self : borrowed (Creusot_Account_Type.t_account)) (other : borrowed (Creusot_Account_Type.t_account)) (amount : uint16) : ()
    requires {[#"/all/creusot.rs" 1493 15 1493 51] Balance0.balance ( * other) + amount <= Max0.mAX'}
    requires {[#"/all/creusot.rs" 1494 15 1494 39] amount <= Balance0.balance ( * self)}
    ensures { [#"/all/creusot.rs" 1495 14 1495 58] Balance0.balance ( ^ self) = Balance0.balance ( * self) - amount }
    ensures { [#"/all/creusot.rs" 1496 14 1496 60] Balance0.balance ( ^ other) = Balance0.balance ( * other) + amount }
    
end
module Creusot_Impl26_Transfer
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt16
  use Creusot_Account_Type as Creusot_Account_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Account_Type.t_account
  clone Core_Num_Impl7_Max as Max0
  clone Creusot_Impl26_Balance as Balance0
  let rec cfg transfer [#"/all/creusot.rs" 1497 4 1497 60] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Creusot_Account_Type.t_account)) (other : borrowed (Creusot_Account_Type.t_account)) (amount : uint16) : ()
    requires {[#"/all/creusot.rs" 1493 15 1493 51] Balance0.balance ( * other) + amount <= Max0.mAX'}
    requires {[#"/all/creusot.rs" 1494 15 1494 39] amount <= Balance0.balance ( * self)}
    ensures { [#"/all/creusot.rs" 1495 14 1495 58] Balance0.balance ( ^ self) = Balance0.balance ( * self) - amount }
    ensures { [#"/all/creusot.rs" 1496 14 1496 60] Balance0.balance ( ^ other) = Balance0.balance ( * other) + amount }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Creusot_Account_Type.t_account);
  var other_2 : borrowed (Creusot_Account_Type.t_account);
  var amount_3 : uint16;
  var de_bal_other_8 : uint16;
  var de_bal_self_9 : uint16;
  var _10 : uint16;
  var _11 : uint16;
  var _12 : uint16;
  var _13 : uint16;
  var _14 : uint16;
  var _15 : uint16;
  {
    self_1 <- self;
    other_2 <- other;
    amount_3 <- amount;
    goto BB0
  }
  BB0 {
    de_bal_other_8 <- Creusot_Account_Type.account_bal ( * other_2);
    de_bal_self_9 <- Creusot_Account_Type.account_bal ( * self_1);
    _11 <- de_bal_self_9;
    _12 <- amount_3;
    _10 <- ([#"/all/creusot.rs" 1500 17 1500 39] _11 - _12);
    self_1 <- { self_1 with current = (let Creusot_Account_Type.C_Account a =  * self_1 in Creusot_Account_Type.C_Account _10) };
    _10 <- any uint16;
    assume { Resolve0.resolve self_1 };
    _14 <- de_bal_other_8;
    _15 <- amount_3;
    _13 <- ([#"/all/creusot.rs" 1501 18 1501 41] _14 + _15);
    other_2 <- { other_2 with current = (let Creusot_Account_Type.C_Account a =  * other_2 in Creusot_Account_Type.C_Account _13) };
    _13 <- any uint16;
    assume { Resolve0.resolve other_2 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_Foo_Interface
  use prelude.Int
  use prelude.Int32
  val foo [#"/all/creusot.rs" 1506 0 1506 31] (my_box : int32) : int32
    ensures { [#"/all/creusot.rs" 1505 10 1505 27] result = my_box }
    
end
module Creusot_Foo
  use prelude.Int
  use prelude.Int32
  let rec cfg foo [#"/all/creusot.rs" 1506 0 1506 31] [@cfg:stackify] [@cfg:subregion_analysis] (my_box : int32) : int32
    ensures { [#"/all/creusot.rs" 1505 10 1505 27] result = my_box }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int32;
  var my_box_1 : int32;
  {
    my_box_1 <- my_box;
    goto BB0
  }
  BB0 {
    _0 <- my_box_1;
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module Creusot_TestTupleField_Interface
  use prelude.Int
  use prelude.Int32
  val test_tuple_field [#"/all/creusot.rs" 1559 0 1559 48] (x : (int32, int32)) : (int32, int32)
    requires {[#"/all/creusot.rs" 1557 11 1557 42] (let (a, _) = x in a) = (123 : int32) /\ (let (_, a) = x in a) = (42 : int32)}
    ensures { [#"/all/creusot.rs" 1558 10 1558 51] (let (a, _) = result in a) = (42 : int32) /\ (let (_, a) = result in a) = (123 : int32) }
    
end
module Creusot_TestTupleField
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int32
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int32,
    type t2 = int32,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve1.resolve
  let rec cfg test_tuple_field [#"/all/creusot.rs" 1559 0 1559 48] [@cfg:stackify] [@cfg:subregion_analysis] (x : (int32, int32)) : (int32, int32)
    requires {[#"/all/creusot.rs" 1557 11 1557 42] (let (a, _) = x in a) = (123 : int32) /\ (let (_, a) = x in a) = (42 : int32)}
    ensures { [#"/all/creusot.rs" 1558 10 1558 51] (let (a, _) = result in a) = (42 : int32) /\ (let (_, a) = result in a) = (123 : int32) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : (int32, int32);
  var x_1 : (int32, int32);
  var _4 : int32;
  var _5 : int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve x_1 };
    _4 <- ([#"/all/creusot.rs" 1560 3 1560 5] (42 : int32));
    _5 <- ([#"/all/creusot.rs" 1560 14 1560 17] (123 : int32));
    _0 <- (_4, _5);
    return _0
  }
  
end
module Creusot_S_Type
  use prelude.Int
  use prelude.Int32
  type t_s  =
    | C_S int32 int32
    
  let function s_a (self : t_s) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_S a _ -> a
      end
  let function s_b (self : t_s) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_S _ a -> a
      end
end
module Creusot_TestStructField_Interface
  use prelude.Int
  use prelude.Int32
  use Creusot_S_Type as Creusot_S_Type
  val test_struct_field [#"/all/creusot.rs" 1564 0 1564 31] (x : Creusot_S_Type.t_s) : Creusot_S_Type.t_s
    requires {[#"/all/creusot.rs" 1562 11 1562 42] Creusot_S_Type.s_a x = (123 : int32) /\ Creusot_S_Type.s_b x = (42 : int32)}
    ensures { [#"/all/creusot.rs" 1563 10 1563 51] Creusot_S_Type.s_a result = (42 : int32) /\ Creusot_S_Type.s_b result = (123 : int32) }
    
end
module Creusot_TestStructField
  use prelude.Int
  use prelude.Int32
  use Creusot_S_Type as Creusot_S_Type
  let rec cfg test_struct_field [#"/all/creusot.rs" 1564 0 1564 31] [@cfg:stackify] [@cfg:subregion_analysis] (x : Creusot_S_Type.t_s) : Creusot_S_Type.t_s
    requires {[#"/all/creusot.rs" 1562 11 1562 42] Creusot_S_Type.s_a x = (123 : int32) /\ Creusot_S_Type.s_b x = (42 : int32)}
    ensures { [#"/all/creusot.rs" 1563 10 1563 51] Creusot_S_Type.s_a result = (42 : int32) /\ Creusot_S_Type.s_b result = (123 : int32) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_S_Type.t_s;
  var x_1 : Creusot_S_Type.t_s;
  var _4 : int32;
  var _5 : int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _4 <- ([#"/all/creusot.rs" 1565 9 1565 11] (42 : int32));
    _5 <- ([#"/all/creusot.rs" 1565 23 1565 26] (123 : int32));
    _0 <- Creusot_S_Type.C_S _4 _5;
    return _0
  }
  
end
module Creusot_Number_Type
  type t_number 'a 'b 'c =
    | C_Number 'a 'b 'c
    
  let function number_b (self : t_number 'a 'b 'c) : 'b = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Number _ a _ -> a
      end
end
module Creusot_Test1_Interface
  type a
  type b
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use Creusot_Number_Type as Creusot_Number_Type
  val test1 [#"/all/creusot.rs" 1571 0 1571 43] (arg : borrowed (Creusot_Number_Type.t_number a int32 b)) : ()
    requires {[#"/all/creusot.rs" 1569 11 1569 52] (-10000 : int32) < Creusot_Number_Type.number_b ( * arg) /\ Creusot_Number_Type.number_b ( * arg) < (10000 : int32)}
    ensures { [#"/all/creusot.rs" 1570 10 1570 38] Creusot_Number_Type.number_b ( ^ arg) = Creusot_Number_Type.number_b ( * arg) - (1000 : int32) }
    
end
module Creusot_Test1
  type a
  type b
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Creusot_Number_Type as Creusot_Number_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Number_Type.t_number a int32 b
  let rec cfg test1 [#"/all/creusot.rs" 1571 0 1571 43] [@cfg:stackify] [@cfg:subregion_analysis] (arg : borrowed (Creusot_Number_Type.t_number a int32 b)) : ()
    requires {[#"/all/creusot.rs" 1569 11 1569 52] (-10000 : int32) < Creusot_Number_Type.number_b ( * arg) /\ Creusot_Number_Type.number_b ( * arg) < (10000 : int32)}
    ensures { [#"/all/creusot.rs" 1570 10 1570 38] Creusot_Number_Type.number_b ( ^ arg) = Creusot_Number_Type.number_b ( * arg) - (1000 : int32) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arg_1 : borrowed (Creusot_Number_Type.t_number a int32 b);
  var de_4 : int32;
  var _5 : int32;
  var _6 : int32;
  {
    arg_1 <- arg;
    goto BB0
  }
  BB0 {
    de_4 <- Creusot_Number_Type.number_b ( * arg_1);
    _6 <- de_4;
    _5 <- ([#"/all/creusot.rs" 1573 10 1573 21] _6 - ([#"/all/creusot.rs" 1573 16 1573 20] (1000 : int32)));
    arg_1 <- { arg_1 with current = (let Creusot_Number_Type.C_Number a b c =  * arg_1 in Creusot_Number_Type.C_Number a _5 c) };
    _5 <- any int32;
    assume { Resolve0.resolve arg_1 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_Test2_Interface
  type a
  type b
  type c
  type d
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use Creusot_Number_Type as Creusot_Number_Type
  val test2 [#"/all/creusot.rs" 1577 0 1577 63] (arg : borrowed (Creusot_Number_Type.t_number a (Creusot_Number_Type.t_number b int32 c) d)) : ()
    requires {[#"/all/creusot.rs" 1575 11 1575 56] (-10000 : int32) < Creusot_Number_Type.number_b (Creusot_Number_Type.number_b ( * arg)) /\ Creusot_Number_Type.number_b (Creusot_Number_Type.number_b ( * arg)) < (10000 : int32)}
    ensures { [#"/all/creusot.rs" 1576 10 1576 42] Creusot_Number_Type.number_b (Creusot_Number_Type.number_b ( ^ arg)) = Creusot_Number_Type.number_b (Creusot_Number_Type.number_b ( * arg)) - (1000 : int32) }
    
end
module Creusot_Test2
  type a
  type b
  type c
  type d
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Creusot_Number_Type as Creusot_Number_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Number_Type.t_number a (Creusot_Number_Type.t_number b int32 c) d
  let rec cfg test2 [#"/all/creusot.rs" 1577 0 1577 63] [@cfg:stackify] [@cfg:subregion_analysis] (arg : borrowed (Creusot_Number_Type.t_number a (Creusot_Number_Type.t_number b int32 c) d)) : ()
    requires {[#"/all/creusot.rs" 1575 11 1575 56] (-10000 : int32) < Creusot_Number_Type.number_b (Creusot_Number_Type.number_b ( * arg)) /\ Creusot_Number_Type.number_b (Creusot_Number_Type.number_b ( * arg)) < (10000 : int32)}
    ensures { [#"/all/creusot.rs" 1576 10 1576 42] Creusot_Number_Type.number_b (Creusot_Number_Type.number_b ( ^ arg)) = Creusot_Number_Type.number_b (Creusot_Number_Type.number_b ( * arg)) - (1000 : int32) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arg_1 : borrowed (Creusot_Number_Type.t_number a (Creusot_Number_Type.t_number b int32 c) d);
  var de_4 : int32;
  var _5 : int32;
  var _6 : int32;
  {
    arg_1 <- arg;
    goto BB0
  }
  BB0 {
    de_4 <- Creusot_Number_Type.number_b (Creusot_Number_Type.number_b ( * arg_1));
    _6 <- de_4;
    _5 <- ([#"/all/creusot.rs" 1579 12 1579 23] _6 - ([#"/all/creusot.rs" 1579 18 1579 22] (1000 : int32)));
    arg_1 <- { arg_1 with current = (let Creusot_Number_Type.C_Number a b c =  * arg_1 in Creusot_Number_Type.C_Number a (let Creusot_Number_Type.C_Number a b c = Creusot_Number_Type.number_b ( * arg_1) in Creusot_Number_Type.C_Number a _5 c) c) };
    _5 <- any int32;
    assume { Resolve0.resolve arg_1 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_BarBaz_Type
  use prelude.Int
  use prelude.Int32
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  type t_barbaz 'b =
    | C_BarBaz int32 (Core_Marker_PhantomData_Type.t_phantomdata 'b)
    
  let function barbaz_i (self : t_barbaz 'b) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_BarBaz a _ -> a
      end
end
module Creusot_Foo4_Type
  use prelude.Int
  use prelude.Int32
  use Creusot_BarBaz_Type as Creusot_BarBaz_Type
  type t_foo4 'a =
    | C_Foo4 int32 (Creusot_BarBaz_Type.t_barbaz 'a)
    
  let function foo4_i (self : t_foo4 'a) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Foo4 a _ -> a
      end
  let function foo4_x (self : t_foo4 'a) : Creusot_BarBaz_Type.t_barbaz 'a = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Foo4 _ a -> a
      end
end
module Creusot_Test1Alt_Interface
  type c
  type d
  use Creusot_BarBaz_Type as Creusot_BarBaz_Type
  use Creusot_Foo4_Type as Creusot_Foo4_Type
  val test1_alt [#"/all/creusot.rs" 1586 0 1586 43] (arg : Creusot_Foo4_Type.t_foo4 c) : Creusot_Foo4_Type.t_foo4 d
    ensures { [#"/all/creusot.rs" 1584 10 1584 29] Creusot_Foo4_Type.foo4_i result = Creusot_BarBaz_Type.barbaz_i (Creusot_Foo4_Type.foo4_x arg) }
    ensures { [#"/all/creusot.rs" 1585 10 1585 29] Creusot_BarBaz_Type.barbaz_i (Creusot_Foo4_Type.foo4_x result) = Creusot_Foo4_Type.foo4_i arg }
    
end
module Creusot_Test1Alt
  type c
  type d
  use prelude.Int
  use prelude.Int32
  use Creusot_BarBaz_Type as Creusot_BarBaz_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Creusot_BarBaz_Type.t_barbaz d
  use Creusot_Foo4_Type as Creusot_Foo4_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Creusot_Foo4_Type.t_foo4 c
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  let rec cfg test1_alt [#"/all/creusot.rs" 1586 0 1586 43] [@cfg:stackify] [@cfg:subregion_analysis] (arg : Creusot_Foo4_Type.t_foo4 c) : Creusot_Foo4_Type.t_foo4 d
    ensures { [#"/all/creusot.rs" 1584 10 1584 29] Creusot_Foo4_Type.foo4_i result = Creusot_BarBaz_Type.barbaz_i (Creusot_Foo4_Type.foo4_x arg) }
    ensures { [#"/all/creusot.rs" 1585 10 1585 29] Creusot_BarBaz_Type.barbaz_i (Creusot_Foo4_Type.foo4_x result) = Creusot_Foo4_Type.foo4_i arg }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Foo4_Type.t_foo4 d;
  var arg_1 : Creusot_Foo4_Type.t_foo4 c;
  var x_4 : Creusot_BarBaz_Type.t_barbaz d;
  var _5 : int32;
  var _6 : Core_Marker_PhantomData_Type.t_phantomdata d;
  var _7 : int32;
  var _8 : Creusot_BarBaz_Type.t_barbaz d;
  {
    arg_1 <- arg;
    goto BB0
  }
  BB0 {
    _5 <- Creusot_Foo4_Type.foo4_i arg_1;
    _6 <- Core_Marker_PhantomData_Type.C_PhantomData;
    x_4 <- Creusot_BarBaz_Type.C_BarBaz _5 _6;
    _7 <- Creusot_BarBaz_Type.barbaz_i (Creusot_Foo4_Type.foo4_x arg_1);
    assume { Resolve0.resolve arg_1 };
    assume { Resolve1.resolve _8 };
    _8 <- x_4;
    x_4 <- any Creusot_BarBaz_Type.t_barbaz d;
    _0 <- Creusot_Foo4_Type.C_Foo4 _7 _8;
    return _0
  }
  
end
module Creusot_TestMatchExpr_Interface
  use prelude.Int
  use prelude.Int32
  use Core_Option_Option_Type as Core_Option_Option_Type
  val test_match_expr [#"/all/creusot.rs" 1593 0 1593 41] (x : int32) : Core_Option_Option_Type.t_option int32
    requires {[#"/all/creusot.rs" 1591 11 1591 23] x = (-42 : int32)}
    ensures { [#"/all/creusot.rs" 1592 10 1592 55] match (result) with
      | Core_Option_Option_Type.C_Some _ -> true
      | _ -> false
      end }
    
end
module Creusot_TestMatchExpr
  use prelude.Int
  use prelude.Int32
  use Core_Option_Option_Type as Core_Option_Option_Type
  let rec cfg test_match_expr [#"/all/creusot.rs" 1593 0 1593 41] [@cfg:stackify] [@cfg:subregion_analysis] (x : int32) : Core_Option_Option_Type.t_option int32
    requires {[#"/all/creusot.rs" 1591 11 1591 23] x = (-42 : int32)}
    ensures { [#"/all/creusot.rs" 1592 10 1592 55] match (result) with
      | Core_Option_Option_Type.C_Some _ -> true
      | _ -> false
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option int32;
  var x_1 : int32;
  var _4 : int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _4 <- ([#"/all/creusot.rs" 1594 7 1594 8] (0 : int32));
    _0 <- Core_Option_Option_Type.C_Some _4;
    return _0
  }
  
end
module Creusot_TestMatchOptionExpr_Interface
  use prelude.Int
  use prelude.Int32
  use Core_Option_Option_Type as Core_Option_Option_Type
  val test_match_option_expr [#"/all/creusot.rs" 1605 0 1605 48] (x : int32) : Core_Option_Option_Type.t_option int32
    requires {[#"/all/creusot.rs" 1603 11 1603 23] x = (-42 : int32)}
    ensures { [#"/all/creusot.rs" 1604 10 1604 62] match (result) with
      | Core_Option_Option_Type.C_Some k -> k = (-42 : int32)
      | _ -> false
      end }
    
end
module Creusot_TestMatchOptionExpr
  use prelude.Int
  use prelude.Int32
  use Core_Option_Option_Type as Core_Option_Option_Type
  let rec cfg test_match_option_expr [#"/all/creusot.rs" 1605 0 1605 48] [@cfg:stackify] [@cfg:subregion_analysis] (x : int32) : Core_Option_Option_Type.t_option int32
    requires {[#"/all/creusot.rs" 1603 11 1603 23] x = (-42 : int32)}
    ensures { [#"/all/creusot.rs" 1604 10 1604 62] match (result) with
      | Core_Option_Option_Type.C_Some k -> k = (-42 : int32)
      | _ -> false
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option int32;
  var x_1 : int32;
  var _4 : int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _4 <- ([#"/all/creusot.rs" 1606 7 1606 12] (-42 : int32));
    _0 <- Core_Option_Option_Type.C_Some _4;
    return _0
  }
  
end
module Creusot_Test1Alt1_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  val test1_alt1 [#"/all/creusot.rs" 1611 0 1611 26] (x : borrowed uint32) : ()
    ensures { [#"/all/creusot.rs" 1610 10 1610 21]  ^ x = (4 : uint32) }
    
end
module Creusot_Test1Alt1
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = uint32
  let rec cfg test1_alt1 [#"/all/creusot.rs" 1611 0 1611 26] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed uint32) : ()
    ensures { [#"/all/creusot.rs" 1610 10 1610 21]  ^ x = (4 : uint32) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed uint32;
  var _3 : uint32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _3 <- ([#"/all/creusot.rs" 1612 7 1612 8] (4 : uint32));
    x_1 <- { x_1 with current = _3 };
    _3 <- any uint32;
    assume { Resolve0.resolve x_1 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_Ts_Type
  use prelude.Int
  use prelude.UInt32
  type t_ts  =
    | C_Ts uint32
    
  let function ts_f (self : t_ts) : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Ts a -> a
      end
end
module Creusot_Test2Alt1_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  use Creusot_Ts_Type as Creusot_Ts_Type
  val test2_alt1 [#"/all/creusot.rs" 1615 0 1615 25] (x : borrowed (Creusot_Ts_Type.t_ts)) : ()
    ensures { [#"/all/creusot.rs" 1614 10 1614 25] Creusot_Ts_Type.ts_f ( ^ x) = (4 : uint32) }
    
end
module Creusot_Test2Alt1
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  use Creusot_Ts_Type as Creusot_Ts_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Ts_Type.t_ts
  let rec cfg test2_alt1 [#"/all/creusot.rs" 1615 0 1615 25] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Creusot_Ts_Type.t_ts)) : ()
    ensures { [#"/all/creusot.rs" 1614 10 1614 25] Creusot_Ts_Type.ts_f ( ^ x) = (4 : uint32) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed (Creusot_Ts_Type.t_ts);
  var new_3 : Creusot_Ts_Type.t_ts;
  var _4 : uint32;
  var _5 : Creusot_Ts_Type.t_ts;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _4 <- ([#"/all/creusot.rs" 1616 20 1616 21] (4 : uint32));
    new_3 <- Creusot_Ts_Type.C_Ts _4;
    _5 <- new_3;
    new_3 <- any Creusot_Ts_Type.t_ts;
    x_1 <- { x_1 with current = _5 };
    _5 <- any Creusot_Ts_Type.t_ts;
    assume { Resolve0.resolve x_1 };
    _0 <- ();
    return _0
  }
  
end
module Creusot_Add_Interface
  use prelude.Int
  use prelude.UInt16
  clone Core_Num_Impl7_Max_Stub as Max0
  val add [#"/all/creusot.rs" 1623 0 1623 39] (a : uint16) (b : uint16) : uint16
    requires {[#"/all/creusot.rs" 1621 11 1621 29] Max0.mAX' - a >= b}
    ensures { [#"/all/creusot.rs" 1622 10 1622 27] result = a + b }
    
end
module Creusot_Add
  use prelude.Int
  use prelude.UInt16
  clone Core_Num_Impl7_Max as Max0
  let rec cfg add [#"/all/creusot.rs" 1623 0 1623 39] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint16) (b : uint16) : uint16
    requires {[#"/all/creusot.rs" 1621 11 1621 29] Max0.mAX' - a >= b}
    ensures { [#"/all/creusot.rs" 1622 10 1622 27] result = a + b }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint16;
  var a_1 : uint16;
  var b_2 : uint16;
  var _5 : uint16;
  var _6 : uint16;
  var _7 : uint16;
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _6 <- a_1;
    _7 <- b_2;
    _5 <- ([#"/all/creusot.rs" 1624 11 1624 19] _6 + _7);
    _0 <- _5;
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Creusot_Point_Type
  use prelude.Int
  use prelude.UInt16
  type t_point  =
    | C_Point uint16 uint16
    
  let function point_x (self : t_point) : uint16 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Point a _ -> a
      end
  let function point_y (self : t_point) : uint16 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Point _ a -> a
      end
end
module Creusot_ShiftX_Interface
  use prelude.Int
  use prelude.UInt16
  use Creusot_Point_Type as Creusot_Point_Type
  clone Core_Num_Impl7_Max_Stub as Max0
  val shift_x [#"/all/creusot.rs" 1629 0 1629 37] (p : Creusot_Point_Type.t_point) (s : uint16) : Creusot_Point_Type.t_point
    requires {[#"/all/creusot.rs" 1626 11 1626 31] Max0.mAX' - Creusot_Point_Type.point_x p >= s}
    ensures { [#"/all/creusot.rs" 1627 10 1627 31] Creusot_Point_Type.point_x result = Creusot_Point_Type.point_x p + s }
    ensures { [#"/all/creusot.rs" 1628 10 1628 27] Creusot_Point_Type.point_y result = Creusot_Point_Type.point_y p }
    
end
module Creusot_ShiftX
  use prelude.Int
  use prelude.UInt16
  clone Core_Num_Impl7_Max as Max0
  use Creusot_Point_Type as Creusot_Point_Type
  let rec cfg shift_x [#"/all/creusot.rs" 1629 0 1629 37] [@cfg:stackify] [@cfg:subregion_analysis] (p : Creusot_Point_Type.t_point) (s : uint16) : Creusot_Point_Type.t_point
    requires {[#"/all/creusot.rs" 1626 11 1626 31] Max0.mAX' - Creusot_Point_Type.point_x p >= s}
    ensures { [#"/all/creusot.rs" 1627 10 1627 31] Creusot_Point_Type.point_x result = Creusot_Point_Type.point_x p + s }
    ensures { [#"/all/creusot.rs" 1628 10 1628 27] Creusot_Point_Type.point_y result = Creusot_Point_Type.point_y p }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Creusot_Point_Type.t_point;
  var p_1 : Creusot_Point_Type.t_point;
  var s_2 : uint16;
  var x_6 : uint16;
  var _7 : uint16;
  var _8 : uint16;
  var _9 : uint16;
  var _10 : uint16;
  var _11 : uint16;
  {
    p_1 <- p;
    s_2 <- s;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _8 <- Creusot_Point_Type.point_x p_1;
    _9 <- s_2;
    _7 <- ([#"/all/creusot.rs" 1630 19 1630 29] _8 + _9);
    x_6 <- _7;
    goto BB4
  }
  BB4 {
    _10 <- x_6;
    x_6 <- any uint16;
    _11 <- Creusot_Point_Type.point_y p_1;
    p_1 <- (let Creusot_Point_Type.C_Point a b = p_1 in Creusot_Point_Type.C_Point a (any uint16));
    _0 <- Creusot_Point_Type.C_Point _10 _11;
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    return _0
  }
  
end
module Creusot_Test6_Interface
  use prelude.Int
  use prelude.UInt32
  use prelude.Borrow
  val test6 [#"/all/creusot.rs" 1636 0 1636 21] (x : uint32) : ()
    requires {[#"/all/creusot.rs" 1634 11 1634 22] x = (5 : uint32)}
    ensures { [#"/all/creusot.rs" 1635 10 1635 21] x = (5 : uint32) }
    
end
module Creusot_Test6
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  let rec cfg test6 [#"/all/creusot.rs" 1636 0 1636 21] [@cfg:stackify] [@cfg:subregion_analysis] (x : uint32) : ()
    requires {[#"/all/creusot.rs" 1634 11 1634 22] x = (5 : uint32)}
    ensures { [#"/all/creusot.rs" 1635 10 1635 21] x = (5 : uint32) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : uint32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _0 <- ();
    return _0
  }
  
end
module Creusot_TestAlt2_Interface
  type t
  use prelude.Borrow
  val test_alt2 [#"/all/creusot.rs" 1639 0 1639 43] (x : t) : t
end
module Creusot_TestAlt2
  type t
  use prelude.Borrow
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = t
  let rec cfg test_alt2 [#"/all/creusot.rs" 1639 0 1639 43] [@cfg:stackify] [@cfg:subregion_analysis] (x : t) : t
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var x_1 : t;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _0 };
    _0 <- x_1;
    assume { Resolve0.resolve x_1 };
    return _0
  }
  
end
module Creusot_U32I64_Interface
  use prelude.Int
  use prelude.UInt32
  use prelude.Int64
  val u32_i64 [#"/all/creusot.rs" 1643 0 1643 29] (x : uint32) : int64
end
module Creusot_U32I64
  use prelude.Int
  use prelude.Int64
  use prelude.UInt32
  let rec cfg u32_i64 [#"/all/creusot.rs" 1643 0 1643 29] [@cfg:stackify] [@cfg:subregion_analysis] (x : uint32) : int64
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int64;
  var x_1 : uint32;
  var _2 : uint32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _2 <- x_1;
    _0 <- Int64.of_int (UInt32.to_int _2);
    return _0
  }
  
end
module Creusot_U32Isize_Interface
  use prelude.Int
  use prelude.UInt32
  use prelude.IntSize
  val u32_isize [#"/all/creusot.rs" 1646 0 1646 33] (x : uint32) : isize
end
module Creusot_U32Isize
  use prelude.Int
  use prelude.IntSize
  use prelude.UInt32
  let rec cfg u32_isize [#"/all/creusot.rs" 1646 0 1646 33] [@cfg:stackify] [@cfg:subregion_analysis] (x : uint32) : isize
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : isize;
  var x_1 : uint32;
  var _2 : uint32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _2 <- x_1;
    _0 <- IntSize.of_int (UInt32.to_int _2);
    return _0
  }
  
end
module Creusot_I32I64_Interface
  use prelude.Int
  use prelude.Int32
  use prelude.Int64
  val i32_i64 [#"/all/creusot.rs" 1682 0 1682 29] (x : int32) : int64
end
module Creusot_I32I64
  use prelude.Int
  use prelude.Int64
  use prelude.Int32
  let rec cfg i32_i64 [#"/all/creusot.rs" 1682 0 1682 29] [@cfg:stackify] [@cfg:subregion_analysis] (x : int32) : int64
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int64;
  var x_1 : int32;
  var _2 : int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _2 <- x_1;
    _0 <- Int64.of_int (Int32.to_int _2);
    return _0
  }
  
end
module Creusot_I32Isize_Interface
  use prelude.Int
  use prelude.Int32
  use prelude.IntSize
  val i32_isize [#"/all/creusot.rs" 1685 0 1685 33] (x : int32) : isize
end
module Creusot_I32Isize
  use prelude.Int
  use prelude.IntSize
  use prelude.Int32
  let rec cfg i32_isize [#"/all/creusot.rs" 1685 0 1685 33] [@cfg:stackify] [@cfg:subregion_analysis] (x : int32) : isize
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : isize;
  var x_1 : int32;
  var _2 : int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _2 <- x_1;
    _0 <- IntSize.of_int (Int32.to_int _2);
    return _0
  }
  
end
module Creusot_U32U64_Interface
  use prelude.Int
  use prelude.UInt32
  use prelude.UInt64
  val u32_u64 [#"/all/creusot.rs" 1705 0 1705 29] (x : uint32) : uint64
end
module Creusot_U32U64
  use prelude.Int
  use prelude.UInt64
  use prelude.UInt32
  let rec cfg u32_u64 [#"/all/creusot.rs" 1705 0 1705 29] [@cfg:stackify] [@cfg:subregion_analysis] (x : uint32) : uint64
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var x_1 : uint32;
  var _2 : uint32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _2 <- x_1;
    _0 <- UInt64.of_int (UInt32.to_int _2);
    return _0
  }
  
end
module Creusot_U32Usize_Interface
  use prelude.Int
  use prelude.UInt32
  use prelude.UIntSize
  val u32_usize [#"/all/creusot.rs" 1708 0 1708 33] (x : uint32) : usize
end
module Creusot_U32Usize
  use prelude.Int
  use prelude.UIntSize
  use prelude.UInt32
  let rec cfg u32_usize [#"/all/creusot.rs" 1708 0 1708 33] [@cfg:stackify] [@cfg:subregion_analysis] (x : uint32) : usize
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var x_1 : uint32;
  var _2 : uint32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _2 <- x_1;
    _0 <- UIntSize.of_int (UInt32.to_int _2);
    return _0
  }
  
end
module Creusot_Ta_Type
  use prelude.Int
  use prelude.Int32
  type t_ta  =
    | C_Ta int32
    
  let function ta_val (self : t_ta) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Ta a -> a
      end
end
module Creusot_Identity_Interface
  use prelude.Borrow
  use Creusot_Ta_Type as Creusot_Ta_Type
  val identity [#"/all/creusot.rs" 1728 0 1728 34] (x : borrowed (Creusot_Ta_Type.t_ta)) : borrowed (Creusot_Ta_Type.t_ta)
    ensures { [#"/all/creusot.rs" 1727 10 1727 35] Creusot_Ta_Type.ta_val ( ^ x) = Creusot_Ta_Type.ta_val ( ^ result) }
    
end
module Creusot_Identity
  use prelude.Borrow
  use Creusot_Ta_Type as Creusot_Ta_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Ta_Type.t_ta
  let rec cfg identity [#"/all/creusot.rs" 1728 0 1728 34] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Creusot_Ta_Type.t_ta)) : borrowed (Creusot_Ta_Type.t_ta)
    ensures { [#"/all/creusot.rs" 1727 10 1727 35] Creusot_Ta_Type.ta_val ( ^ x) = Creusot_Ta_Type.ta_val ( ^ result) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed (Creusot_Ta_Type.t_ta);
  var x_1 : borrowed (Creusot_Ta_Type.t_ta);
  var _2 : borrowed (Creusot_Ta_Type.t_ta);
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _2 <- borrow_mut ( * x_1);
    x_1 <- { x_1 with current = ( ^ _2) };
    assume { Resolve0.resolve x_1 };
    _0 <- borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Resolve0.resolve _2 };
    return _0
  }
  
end
module Creusot_Identity2_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Creusot_Ta_Type as Creusot_Ta_Type
  val identity2 [#"/all/creusot.rs" 1733 0 1733 43] (x : borrowed (Creusot_Ta_Type.t_ta)) (v : int32) : borrowed (Creusot_Ta_Type.t_ta)
    ensures { [#"/all/creusot.rs" 1731 10 1731 25] Creusot_Ta_Type.ta_val ( * result) = v }
    ensures { [#"/all/creusot.rs" 1732 10 1732 35] Creusot_Ta_Type.ta_val ( ^ x) = Creusot_Ta_Type.ta_val ( ^ result) }
    
end
module Creusot_Identity2
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Creusot_Ta_Type as Creusot_Ta_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Ta_Type.t_ta
  let rec cfg identity2 [#"/all/creusot.rs" 1733 0 1733 43] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Creusot_Ta_Type.t_ta)) (v : int32) : borrowed (Creusot_Ta_Type.t_ta)
    ensures { [#"/all/creusot.rs" 1731 10 1731 25] Creusot_Ta_Type.ta_val ( * result) = v }
    ensures { [#"/all/creusot.rs" 1732 10 1732 35] Creusot_Ta_Type.ta_val ( ^ x) = Creusot_Ta_Type.ta_val ( ^ result) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed (Creusot_Ta_Type.t_ta);
  var x_1 : borrowed (Creusot_Ta_Type.t_ta);
  var v_2 : int32;
  var _3 : borrowed (Creusot_Ta_Type.t_ta);
  var new_6 : Creusot_Ta_Type.t_ta;
  var _7 : int32;
  var _8 : Creusot_Ta_Type.t_ta;
  {
    x_1 <- x;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _7 <- v_2;
    new_6 <- Creusot_Ta_Type.C_Ta _7;
    _8 <- new_6;
    new_6 <- any Creusot_Ta_Type.t_ta;
    x_1 <- { x_1 with current = _8 };
    _8 <- any Creusot_Ta_Type.t_ta;
    _3 <- borrow_mut ( * x_1);
    x_1 <- { x_1 with current = ( ^ _3) };
    assume { Resolve0.resolve x_1 };
    _0 <- borrow_mut ( * _3);
    _3 <- { _3 with current = ( ^ _0) };
    assume { Resolve0.resolve _3 };
    return _0
  }
  
end
module Creusot_Identity3_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Creusot_Ta_Type as Creusot_Ta_Type
  val identity3 [#"/all/creusot.rs" 1740 0 1740 44] (x : borrowed (Creusot_Ta_Type.t_ta)) (v : int32) : borrowed int32
    ensures { [#"/all/creusot.rs" 1738 10 1738 22]  * result = v }
    ensures { [#"/all/creusot.rs" 1739 10 1739 31] Creusot_Ta_Type.ta_val ( ^ x) =  ^ result }
    
end
module Creusot_Identity3
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  use Creusot_Ta_Type as Creusot_Ta_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Creusot_Ta_Type.t_ta
  let rec cfg identity3 [#"/all/creusot.rs" 1740 0 1740 44] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Creusot_Ta_Type.t_ta)) (v : int32) : borrowed int32
    ensures { [#"/all/creusot.rs" 1738 10 1738 22]  * result = v }
    ensures { [#"/all/creusot.rs" 1739 10 1739 31] Creusot_Ta_Type.ta_val ( ^ x) =  ^ result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed int32;
  var x_1 : borrowed (Creusot_Ta_Type.t_ta);
  var v_2 : int32;
  var _3 : borrowed int32;
  var _6 : int32;
  var _7 : borrowed int32;
  {
    x_1 <- x;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _6 <- v_2;
    x_1 <- { x_1 with current = (let Creusot_Ta_Type.C_Ta a =  * x_1 in Creusot_Ta_Type.C_Ta _6) };
    _6 <- any int32;
    _7 <- borrow_mut (Creusot_Ta_Type.ta_val ( * x_1));
    x_1 <- { x_1 with current = (let Creusot_Ta_Type.C_Ta a =  * x_1 in Creusot_Ta_Type.C_Ta ( ^ _7)) };
    assume { Resolve0.resolve x_1 };
    _3 <- borrow_mut ( * _7);
    _7 <- { _7 with current = ( ^ _3) };
    assume { Resolve1.resolve _7 };
    _0 <- borrow_mut ( * _3);
    _3 <- { _3 with current = ( ^ _0) };
    assume { Resolve1.resolve _3 };
    return _0
  }
  
end
module Creusot_Impl27
  type t
end
module Creusot_Impl28
  type t
end
module Creusot_Impl31
  type t
end
module Creusot_Impl32
  type t
end
module Creusot_Impl33
  type t
end
module Creusot_Impl34
  type t
end
module Creusot_Impl29
  
end
module Creusot_Impl30
  use prelude.Borrow
  use Creusot_Foo2_Type as Creusot_Foo2_Type
  goal clone'_refn : [#"/all/creusot.rs" 252 15 252 32] forall self : Creusot_Foo2_Type.t_foo2 . forall result : Creusot_Foo2_Type.t_foo2 . result = self
end
